"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/iconify-icon@1.0.8";
exports.ids = ["vendor-chunks/iconify-icon@1.0.8"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/iconify-icon@1.0.8/node_modules/iconify-icon/dist/iconify-icon.mjs":
/*!***********************************************************************************************!*\
  !*** ./node_modules/.pnpm/iconify-icon@1.0.8/node_modules/iconify-icon/dist/iconify-icon.mjs ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   IconifyIconComponent: () => (/* binding */ IconifyIconComponent),\n/* harmony export */   _api: () => (/* binding */ _api),\n/* harmony export */   addAPIProvider: () => (/* binding */ addAPIProvider),\n/* harmony export */   addCollection: () => (/* binding */ addCollection),\n/* harmony export */   addIcon: () => (/* binding */ addIcon),\n/* harmony export */   appendCustomStyle: () => (/* binding */ appendCustomStyle),\n/* harmony export */   buildIcon: () => (/* binding */ buildIcon),\n/* harmony export */   calculateSize: () => (/* binding */ calculateSize),\n/* harmony export */   disableCache: () => (/* binding */ disableCache),\n/* harmony export */   enableCache: () => (/* binding */ enableCache),\n/* harmony export */   getIcon: () => (/* binding */ getIcon),\n/* harmony export */   iconExists: () => (/* binding */ iconExists),\n/* harmony export */   listIcons: () => (/* binding */ listIcons),\n/* harmony export */   loadIcon: () => (/* binding */ loadIcon),\n/* harmony export */   loadIcons: () => (/* binding */ loadIcons)\n/* harmony export */ });\n/**\n* (c) Iconify\n*\n* For the full copyright and license information, please view the license.txt\n* files at https://github.com/iconify/iconify\n*\n* Licensed under MIT.\n*\n* @license MIT\n* @version 1.0.8\n*/ const defaultIconDimensions = Object.freeze({\n    left: 0,\n    top: 0,\n    width: 16,\n    height: 16\n});\nconst defaultIconTransformations = Object.freeze({\n    rotate: 0,\n    vFlip: false,\n    hFlip: false\n});\nconst defaultIconProps = Object.freeze({\n    ...defaultIconDimensions,\n    ...defaultIconTransformations\n});\nconst defaultExtendedIconProps = Object.freeze({\n    ...defaultIconProps,\n    body: \"\",\n    hidden: false\n});\nconst defaultIconSizeCustomisations = Object.freeze({\n    width: null,\n    height: null\n});\nconst defaultIconCustomisations = Object.freeze({\n    // Dimensions\n    ...defaultIconSizeCustomisations,\n    // Transformations\n    ...defaultIconTransformations\n});\nfunction rotateFromString(value, defaultValue = 0) {\n    const units = value.replace(/^-?[0-9.]*/, \"\");\n    function cleanup(value2) {\n        while(value2 < 0){\n            value2 += 4;\n        }\n        return value2 % 4;\n    }\n    if (units === \"\") {\n        const num = parseInt(value);\n        return isNaN(num) ? 0 : cleanup(num);\n    } else if (units !== value) {\n        let split = 0;\n        switch(units){\n            case \"%\":\n                split = 25;\n                break;\n            case \"deg\":\n                split = 90;\n        }\n        if (split) {\n            let num = parseFloat(value.slice(0, value.length - units.length));\n            if (isNaN(num)) {\n                return 0;\n            }\n            num = num / split;\n            return num % 1 === 0 ? cleanup(num) : 0;\n        }\n    }\n    return defaultValue;\n}\nconst separator = /[\\s,]+/;\nfunction flipFromString(custom, flip) {\n    flip.split(separator).forEach((str)=>{\n        const value = str.trim();\n        switch(value){\n            case \"horizontal\":\n                custom.hFlip = true;\n                break;\n            case \"vertical\":\n                custom.vFlip = true;\n                break;\n        }\n    });\n}\nconst defaultCustomisations = {\n    ...defaultIconCustomisations,\n    preserveAspectRatio: \"\"\n};\n/**\n * Get customisations\n */ function getCustomisations(node) {\n    const customisations = {\n        ...defaultCustomisations\n    };\n    const attr = (key, def)=>node.getAttribute(key) || def;\n    // Dimensions\n    customisations.width = attr(\"width\", null);\n    customisations.height = attr(\"height\", null);\n    // Rotation\n    customisations.rotate = rotateFromString(attr(\"rotate\", \"\"));\n    // Flip\n    flipFromString(customisations, attr(\"flip\", \"\"));\n    // SVG attributes\n    customisations.preserveAspectRatio = attr(\"preserveAspectRatio\", attr(\"preserveaspectratio\", \"\"));\n    return customisations;\n}\n/**\n * Check if customisations have been updated\n */ function haveCustomisationsChanged(value1, value2) {\n    for(const key in defaultCustomisations){\n        if (value1[key] !== value2[key]) {\n            return true;\n        }\n    }\n    return false;\n}\nconst matchIconName = /^[a-z0-9]+(-[a-z0-9]+)*$/;\nconst stringToIcon = (value, validate, allowSimpleName, provider = \"\")=>{\n    const colonSeparated = value.split(\":\");\n    if (value.slice(0, 1) === \"@\") {\n        if (colonSeparated.length < 2 || colonSeparated.length > 3) {\n            return null;\n        }\n        provider = colonSeparated.shift().slice(1);\n    }\n    if (colonSeparated.length > 3 || !colonSeparated.length) {\n        return null;\n    }\n    if (colonSeparated.length > 1) {\n        const name2 = colonSeparated.pop();\n        const prefix = colonSeparated.pop();\n        const result = {\n            // Allow provider without '@': \"provider:prefix:name\"\n            provider: colonSeparated.length > 0 ? colonSeparated[0] : provider,\n            prefix,\n            name: name2\n        };\n        return validate && !validateIconName(result) ? null : result;\n    }\n    const name = colonSeparated[0];\n    const dashSeparated = name.split(\"-\");\n    if (dashSeparated.length > 1) {\n        const result = {\n            provider,\n            prefix: dashSeparated.shift(),\n            name: dashSeparated.join(\"-\")\n        };\n        return validate && !validateIconName(result) ? null : result;\n    }\n    if (allowSimpleName && provider === \"\") {\n        const result = {\n            provider,\n            prefix: \"\",\n            name\n        };\n        return validate && !validateIconName(result, allowSimpleName) ? null : result;\n    }\n    return null;\n};\nconst validateIconName = (icon, allowSimpleName)=>{\n    if (!icon) {\n        return false;\n    }\n    return !!((icon.provider === \"\" || icon.provider.match(matchIconName)) && (allowSimpleName && icon.prefix === \"\" || icon.prefix.match(matchIconName)) && icon.name.match(matchIconName));\n};\nfunction mergeIconTransformations(obj1, obj2) {\n    const result = {};\n    if (!obj1.hFlip !== !obj2.hFlip) {\n        result.hFlip = true;\n    }\n    if (!obj1.vFlip !== !obj2.vFlip) {\n        result.vFlip = true;\n    }\n    const rotate = ((obj1.rotate || 0) + (obj2.rotate || 0)) % 4;\n    if (rotate) {\n        result.rotate = rotate;\n    }\n    return result;\n}\nfunction mergeIconData(parent, child) {\n    const result = mergeIconTransformations(parent, child);\n    for(const key in defaultExtendedIconProps){\n        if (key in defaultIconTransformations) {\n            if (key in parent && !(key in result)) {\n                result[key] = defaultIconTransformations[key];\n            }\n        } else if (key in child) {\n            result[key] = child[key];\n        } else if (key in parent) {\n            result[key] = parent[key];\n        }\n    }\n    return result;\n}\nfunction getIconsTree(data, names) {\n    const icons = data.icons;\n    const aliases = data.aliases || /* @__PURE__ */ Object.create(null);\n    const resolved = /* @__PURE__ */ Object.create(null);\n    function resolve(name) {\n        if (icons[name]) {\n            return resolved[name] = [];\n        }\n        if (!(name in resolved)) {\n            resolved[name] = null;\n            const parent = aliases[name] && aliases[name].parent;\n            const value = parent && resolve(parent);\n            if (value) {\n                resolved[name] = [\n                    parent\n                ].concat(value);\n            }\n        }\n        return resolved[name];\n    }\n    (names || Object.keys(icons).concat(Object.keys(aliases))).forEach(resolve);\n    return resolved;\n}\nfunction internalGetIconData(data, name, tree) {\n    const icons = data.icons;\n    const aliases = data.aliases || /* @__PURE__ */ Object.create(null);\n    let currentProps = {};\n    function parse(name2) {\n        currentProps = mergeIconData(icons[name2] || aliases[name2], currentProps);\n    }\n    parse(name);\n    tree.forEach(parse);\n    return mergeIconData(data, currentProps);\n}\nfunction parseIconSet(data, callback) {\n    const names = [];\n    if (typeof data !== \"object\" || typeof data.icons !== \"object\") {\n        return names;\n    }\n    if (data.not_found instanceof Array) {\n        data.not_found.forEach((name)=>{\n            callback(name, null);\n            names.push(name);\n        });\n    }\n    const tree = getIconsTree(data);\n    for(const name in tree){\n        const item = tree[name];\n        if (item) {\n            callback(name, internalGetIconData(data, name, item));\n            names.push(name);\n        }\n    }\n    return names;\n}\nconst optionalPropertyDefaults = {\n    provider: \"\",\n    aliases: {},\n    not_found: {},\n    ...defaultIconDimensions\n};\nfunction checkOptionalProps(item, defaults) {\n    for(const prop in defaults){\n        if (prop in item && typeof item[prop] !== typeof defaults[prop]) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction quicklyValidateIconSet(obj) {\n    if (typeof obj !== \"object\" || obj === null) {\n        return null;\n    }\n    const data = obj;\n    if (typeof data.prefix !== \"string\" || !obj.icons || typeof obj.icons !== \"object\") {\n        return null;\n    }\n    if (!checkOptionalProps(obj, optionalPropertyDefaults)) {\n        return null;\n    }\n    const icons = data.icons;\n    for(const name in icons){\n        const icon = icons[name];\n        if (!name.match(matchIconName) || typeof icon.body !== \"string\" || !checkOptionalProps(icon, defaultExtendedIconProps)) {\n            return null;\n        }\n    }\n    const aliases = data.aliases || /* @__PURE__ */ Object.create(null);\n    for(const name in aliases){\n        const icon = aliases[name];\n        const parent = icon.parent;\n        if (!name.match(matchIconName) || typeof parent !== \"string\" || !icons[parent] && !aliases[parent] || !checkOptionalProps(icon, defaultExtendedIconProps)) {\n            return null;\n        }\n    }\n    return data;\n}\nconst dataStorage = /* @__PURE__ */ Object.create(null);\nfunction newStorage(provider, prefix) {\n    return {\n        provider,\n        prefix,\n        icons: /* @__PURE__ */ Object.create(null),\n        missing: /* @__PURE__ */ new Set()\n    };\n}\nfunction getStorage(provider, prefix) {\n    const providerStorage = dataStorage[provider] || (dataStorage[provider] = /* @__PURE__ */ Object.create(null));\n    return providerStorage[prefix] || (providerStorage[prefix] = newStorage(provider, prefix));\n}\nfunction addIconSet(storage, data) {\n    if (!quicklyValidateIconSet(data)) {\n        return [];\n    }\n    return parseIconSet(data, (name, icon)=>{\n        if (icon) {\n            storage.icons[name] = icon;\n        } else {\n            storage.missing.add(name);\n        }\n    });\n}\nfunction addIconToStorage(storage, name, icon) {\n    try {\n        if (typeof icon.body === \"string\") {\n            storage.icons[name] = {\n                ...icon\n            };\n            return true;\n        }\n    } catch (err) {}\n    return false;\n}\nfunction listIcons$1(provider, prefix) {\n    let allIcons = [];\n    const providers = typeof provider === \"string\" ? [\n        provider\n    ] : Object.keys(dataStorage);\n    providers.forEach((provider2)=>{\n        const prefixes = typeof provider2 === \"string\" && typeof prefix === \"string\" ? [\n            prefix\n        ] : Object.keys(dataStorage[provider2] || {});\n        prefixes.forEach((prefix2)=>{\n            const storage = getStorage(provider2, prefix2);\n            allIcons = allIcons.concat(Object.keys(storage.icons).map((name)=>(provider2 !== \"\" ? \"@\" + provider2 + \":\" : \"\") + prefix2 + \":\" + name));\n        });\n    });\n    return allIcons;\n}\nlet simpleNames = false;\nfunction allowSimpleNames(allow) {\n    if (typeof allow === \"boolean\") {\n        simpleNames = allow;\n    }\n    return simpleNames;\n}\nfunction getIconData(name) {\n    const icon = typeof name === \"string\" ? stringToIcon(name, true, simpleNames) : name;\n    if (icon) {\n        const storage = getStorage(icon.provider, icon.prefix);\n        const iconName = icon.name;\n        return storage.icons[iconName] || (storage.missing.has(iconName) ? null : void 0);\n    }\n}\nfunction addIcon$1(name, data) {\n    const icon = stringToIcon(name, true, simpleNames);\n    if (!icon) {\n        return false;\n    }\n    const storage = getStorage(icon.provider, icon.prefix);\n    return addIconToStorage(storage, icon.name, data);\n}\nfunction addCollection$1(data, provider) {\n    if (typeof data !== \"object\") {\n        return false;\n    }\n    if (typeof provider !== \"string\") {\n        provider = data.provider || \"\";\n    }\n    if (simpleNames && !provider && !data.prefix) {\n        let added = false;\n        if (quicklyValidateIconSet(data)) {\n            data.prefix = \"\";\n            parseIconSet(data, (name, icon)=>{\n                if (icon && addIcon$1(name, icon)) {\n                    added = true;\n                }\n            });\n        }\n        return added;\n    }\n    const prefix = data.prefix;\n    if (!validateIconName({\n        provider,\n        prefix,\n        name: \"a\"\n    })) {\n        return false;\n    }\n    const storage = getStorage(provider, prefix);\n    return !!addIconSet(storage, data);\n}\nfunction iconExists$1(name) {\n    return !!getIconData(name);\n}\nfunction getIcon$1(name) {\n    const result = getIconData(name);\n    return result ? {\n        ...defaultIconProps,\n        ...result\n    } : null;\n}\nfunction sortIcons(icons) {\n    const result = {\n        loaded: [],\n        missing: [],\n        pending: []\n    };\n    const storage = /* @__PURE__ */ Object.create(null);\n    icons.sort((a, b)=>{\n        if (a.provider !== b.provider) {\n            return a.provider.localeCompare(b.provider);\n        }\n        if (a.prefix !== b.prefix) {\n            return a.prefix.localeCompare(b.prefix);\n        }\n        return a.name.localeCompare(b.name);\n    });\n    let lastIcon = {\n        provider: \"\",\n        prefix: \"\",\n        name: \"\"\n    };\n    icons.forEach((icon)=>{\n        if (lastIcon.name === icon.name && lastIcon.prefix === icon.prefix && lastIcon.provider === icon.provider) {\n            return;\n        }\n        lastIcon = icon;\n        const provider = icon.provider;\n        const prefix = icon.prefix;\n        const name = icon.name;\n        const providerStorage = storage[provider] || (storage[provider] = /* @__PURE__ */ Object.create(null));\n        const localStorage = providerStorage[prefix] || (providerStorage[prefix] = getStorage(provider, prefix));\n        let list;\n        if (name in localStorage.icons) {\n            list = result.loaded;\n        } else if (prefix === \"\" || localStorage.missing.has(name)) {\n            list = result.missing;\n        } else {\n            list = result.pending;\n        }\n        const item = {\n            provider,\n            prefix,\n            name\n        };\n        list.push(item);\n    });\n    return result;\n}\nfunction removeCallback(storages, id) {\n    storages.forEach((storage)=>{\n        const items = storage.loaderCallbacks;\n        if (items) {\n            storage.loaderCallbacks = items.filter((row)=>row.id !== id);\n        }\n    });\n}\nfunction updateCallbacks(storage) {\n    if (!storage.pendingCallbacksFlag) {\n        storage.pendingCallbacksFlag = true;\n        setTimeout(()=>{\n            storage.pendingCallbacksFlag = false;\n            const items = storage.loaderCallbacks ? storage.loaderCallbacks.slice(0) : [];\n            if (!items.length) {\n                return;\n            }\n            let hasPending = false;\n            const provider = storage.provider;\n            const prefix = storage.prefix;\n            items.forEach((item)=>{\n                const icons = item.icons;\n                const oldLength = icons.pending.length;\n                icons.pending = icons.pending.filter((icon)=>{\n                    if (icon.prefix !== prefix) {\n                        return true;\n                    }\n                    const name = icon.name;\n                    if (storage.icons[name]) {\n                        icons.loaded.push({\n                            provider,\n                            prefix,\n                            name\n                        });\n                    } else if (storage.missing.has(name)) {\n                        icons.missing.push({\n                            provider,\n                            prefix,\n                            name\n                        });\n                    } else {\n                        hasPending = true;\n                        return true;\n                    }\n                    return false;\n                });\n                if (icons.pending.length !== oldLength) {\n                    if (!hasPending) {\n                        removeCallback([\n                            storage\n                        ], item.id);\n                    }\n                    item.callback(icons.loaded.slice(0), icons.missing.slice(0), icons.pending.slice(0), item.abort);\n                }\n            });\n        });\n    }\n}\nlet idCounter = 0;\nfunction storeCallback(callback, icons, pendingSources) {\n    const id = idCounter++;\n    const abort = removeCallback.bind(null, pendingSources, id);\n    if (!icons.pending.length) {\n        return abort;\n    }\n    const item = {\n        id,\n        icons,\n        callback,\n        abort\n    };\n    pendingSources.forEach((storage)=>{\n        (storage.loaderCallbacks || (storage.loaderCallbacks = [])).push(item);\n    });\n    return abort;\n}\nconst storage = /* @__PURE__ */ Object.create(null);\nfunction setAPIModule(provider, item) {\n    storage[provider] = item;\n}\nfunction getAPIModule(provider) {\n    return storage[provider] || storage[\"\"];\n}\nfunction listToIcons(list, validate = true, simpleNames = false) {\n    const result = [];\n    list.forEach((item)=>{\n        const icon = typeof item === \"string\" ? stringToIcon(item, validate, simpleNames) : item;\n        if (icon) {\n            result.push(icon);\n        }\n    });\n    return result;\n}\n// src/config.ts\nvar defaultConfig = {\n    resources: [],\n    index: 0,\n    timeout: 2e3,\n    rotate: 750,\n    random: false,\n    dataAfterTimeout: false\n};\n// src/query.ts\nfunction sendQuery(config, payload, query, done) {\n    const resourcesCount = config.resources.length;\n    const startIndex = config.random ? Math.floor(Math.random() * resourcesCount) : config.index;\n    let resources;\n    if (config.random) {\n        let list = config.resources.slice(0);\n        resources = [];\n        while(list.length > 1){\n            const nextIndex = Math.floor(Math.random() * list.length);\n            resources.push(list[nextIndex]);\n            list = list.slice(0, nextIndex).concat(list.slice(nextIndex + 1));\n        }\n        resources = resources.concat(list);\n    } else {\n        resources = config.resources.slice(startIndex).concat(config.resources.slice(0, startIndex));\n    }\n    const startTime = Date.now();\n    let status = \"pending\";\n    let queriesSent = 0;\n    let lastError;\n    let timer = null;\n    let queue = [];\n    let doneCallbacks = [];\n    if (typeof done === \"function\") {\n        doneCallbacks.push(done);\n    }\n    function resetTimer() {\n        if (timer) {\n            clearTimeout(timer);\n            timer = null;\n        }\n    }\n    function abort() {\n        if (status === \"pending\") {\n            status = \"aborted\";\n        }\n        resetTimer();\n        queue.forEach((item)=>{\n            if (item.status === \"pending\") {\n                item.status = \"aborted\";\n            }\n        });\n        queue = [];\n    }\n    function subscribe(callback, overwrite) {\n        if (overwrite) {\n            doneCallbacks = [];\n        }\n        if (typeof callback === \"function\") {\n            doneCallbacks.push(callback);\n        }\n    }\n    function getQueryStatus() {\n        return {\n            startTime,\n            payload,\n            status,\n            queriesSent,\n            queriesPending: queue.length,\n            subscribe,\n            abort\n        };\n    }\n    function failQuery() {\n        status = \"failed\";\n        doneCallbacks.forEach((callback)=>{\n            callback(void 0, lastError);\n        });\n    }\n    function clearQueue() {\n        queue.forEach((item)=>{\n            if (item.status === \"pending\") {\n                item.status = \"aborted\";\n            }\n        });\n        queue = [];\n    }\n    function moduleResponse(item, response, data) {\n        const isError = response !== \"success\";\n        queue = queue.filter((queued)=>queued !== item);\n        switch(status){\n            case \"pending\":\n                break;\n            case \"failed\":\n                if (isError || !config.dataAfterTimeout) {\n                    return;\n                }\n                break;\n            default:\n                return;\n        }\n        if (response === \"abort\") {\n            lastError = data;\n            failQuery();\n            return;\n        }\n        if (isError) {\n            lastError = data;\n            if (!queue.length) {\n                if (!resources.length) {\n                    failQuery();\n                } else {\n                    execNext();\n                }\n            }\n            return;\n        }\n        resetTimer();\n        clearQueue();\n        if (!config.random) {\n            const index = config.resources.indexOf(item.resource);\n            if (index !== -1 && index !== config.index) {\n                config.index = index;\n            }\n        }\n        status = \"completed\";\n        doneCallbacks.forEach((callback)=>{\n            callback(data);\n        });\n    }\n    function execNext() {\n        if (status !== \"pending\") {\n            return;\n        }\n        resetTimer();\n        const resource = resources.shift();\n        if (resource === void 0) {\n            if (queue.length) {\n                timer = setTimeout(()=>{\n                    resetTimer();\n                    if (status === \"pending\") {\n                        clearQueue();\n                        failQuery();\n                    }\n                }, config.timeout);\n                return;\n            }\n            failQuery();\n            return;\n        }\n        const item = {\n            status: \"pending\",\n            resource,\n            callback: (status2, data)=>{\n                moduleResponse(item, status2, data);\n            }\n        };\n        queue.push(item);\n        queriesSent++;\n        timer = setTimeout(execNext, config.rotate);\n        query(resource, payload, item.callback);\n    }\n    setTimeout(execNext);\n    return getQueryStatus;\n}\n// src/index.ts\nfunction initRedundancy(cfg) {\n    const config = {\n        ...defaultConfig,\n        ...cfg\n    };\n    let queries = [];\n    function cleanup() {\n        queries = queries.filter((item)=>item().status === \"pending\");\n    }\n    function query(payload, queryCallback, doneCallback) {\n        const query2 = sendQuery(config, payload, queryCallback, (data, error)=>{\n            cleanup();\n            if (doneCallback) {\n                doneCallback(data, error);\n            }\n        });\n        queries.push(query2);\n        return query2;\n    }\n    function find(callback) {\n        return queries.find((value)=>{\n            return callback(value);\n        }) || null;\n    }\n    const instance = {\n        query,\n        find,\n        setIndex: (index)=>{\n            config.index = index;\n        },\n        getIndex: ()=>config.index,\n        cleanup\n    };\n    return instance;\n}\nfunction createAPIConfig(source) {\n    let resources;\n    if (typeof source.resources === \"string\") {\n        resources = [\n            source.resources\n        ];\n    } else {\n        resources = source.resources;\n        if (!(resources instanceof Array) || !resources.length) {\n            return null;\n        }\n    }\n    const result = {\n        // API hosts\n        resources,\n        // Root path\n        path: source.path || \"/\",\n        // URL length limit\n        maxURL: source.maxURL || 500,\n        // Timeout before next host is used.\n        rotate: source.rotate || 750,\n        // Timeout before failing query.\n        timeout: source.timeout || 5e3,\n        // Randomise default API end point.\n        random: source.random === true,\n        // Start index\n        index: source.index || 0,\n        // Receive data after time out (used if time out kicks in first, then API module sends data anyway).\n        dataAfterTimeout: source.dataAfterTimeout !== false\n    };\n    return result;\n}\nconst configStorage = /* @__PURE__ */ Object.create(null);\nconst fallBackAPISources = [\n    \"https://api.simplesvg.com\",\n    \"https://api.unisvg.com\"\n];\nconst fallBackAPI = [];\nwhile(fallBackAPISources.length > 0){\n    if (fallBackAPISources.length === 1) {\n        fallBackAPI.push(fallBackAPISources.shift());\n    } else {\n        if (Math.random() > 0.5) {\n            fallBackAPI.push(fallBackAPISources.shift());\n        } else {\n            fallBackAPI.push(fallBackAPISources.pop());\n        }\n    }\n}\nconfigStorage[\"\"] = createAPIConfig({\n    resources: [\n        \"https://api.iconify.design\"\n    ].concat(fallBackAPI)\n});\nfunction addAPIProvider$1(provider, customConfig) {\n    const config = createAPIConfig(customConfig);\n    if (config === null) {\n        return false;\n    }\n    configStorage[provider] = config;\n    return true;\n}\nfunction getAPIConfig(provider) {\n    return configStorage[provider];\n}\nfunction listAPIProviders() {\n    return Object.keys(configStorage);\n}\nfunction emptyCallback$1() {}\nconst redundancyCache = /* @__PURE__ */ Object.create(null);\nfunction getRedundancyCache(provider) {\n    if (!redundancyCache[provider]) {\n        const config = getAPIConfig(provider);\n        if (!config) {\n            return;\n        }\n        const redundancy = initRedundancy(config);\n        const cachedReundancy = {\n            config,\n            redundancy\n        };\n        redundancyCache[provider] = cachedReundancy;\n    }\n    return redundancyCache[provider];\n}\nfunction sendAPIQuery(target, query, callback) {\n    let redundancy;\n    let send;\n    if (typeof target === \"string\") {\n        const api = getAPIModule(target);\n        if (!api) {\n            callback(void 0, 424);\n            return emptyCallback$1;\n        }\n        send = api.send;\n        const cached = getRedundancyCache(target);\n        if (cached) {\n            redundancy = cached.redundancy;\n        }\n    } else {\n        const config = createAPIConfig(target);\n        if (config) {\n            redundancy = initRedundancy(config);\n            const moduleKey = target.resources ? target.resources[0] : \"\";\n            const api = getAPIModule(moduleKey);\n            if (api) {\n                send = api.send;\n            }\n        }\n    }\n    if (!redundancy || !send) {\n        callback(void 0, 424);\n        return emptyCallback$1;\n    }\n    return redundancy.query(query, send, callback)().abort;\n}\nconst browserCacheVersion = \"iconify2\";\nconst browserCachePrefix = \"iconify\";\nconst browserCacheCountKey = browserCachePrefix + \"-count\";\nconst browserCacheVersionKey = browserCachePrefix + \"-version\";\nconst browserStorageHour = 36e5;\nconst browserStorageCacheExpiration = 168;\nfunction getStoredItem(func, key) {\n    try {\n        return func.getItem(key);\n    } catch (err) {}\n}\nfunction setStoredItem(func, key, value) {\n    try {\n        func.setItem(key, value);\n        return true;\n    } catch (err) {}\n}\nfunction removeStoredItem(func, key) {\n    try {\n        func.removeItem(key);\n    } catch (err) {}\n}\nfunction setBrowserStorageItemsCount(storage, value) {\n    return setStoredItem(storage, browserCacheCountKey, value.toString());\n}\nfunction getBrowserStorageItemsCount(storage) {\n    return parseInt(getStoredItem(storage, browserCacheCountKey)) || 0;\n}\nconst browserStorageConfig = {\n    local: true,\n    session: true\n};\nconst browserStorageEmptyItems = {\n    local: /* @__PURE__ */ new Set(),\n    session: /* @__PURE__ */ new Set()\n};\nlet browserStorageStatus = false;\nfunction setBrowserStorageStatus(status) {\n    browserStorageStatus = status;\n}\nlet _window =  true ? {} : 0;\nfunction getBrowserStorage(key) {\n    const attr = key + \"Storage\";\n    try {\n        if (_window && _window[attr] && typeof _window[attr].length === \"number\") {\n            return _window[attr];\n        }\n    } catch (err) {}\n    browserStorageConfig[key] = false;\n}\nfunction iterateBrowserStorage(key, callback) {\n    const func = getBrowserStorage(key);\n    if (!func) {\n        return;\n    }\n    const version = getStoredItem(func, browserCacheVersionKey);\n    if (version !== browserCacheVersion) {\n        if (version) {\n            const total2 = getBrowserStorageItemsCount(func);\n            for(let i = 0; i < total2; i++){\n                removeStoredItem(func, browserCachePrefix + i.toString());\n            }\n        }\n        setStoredItem(func, browserCacheVersionKey, browserCacheVersion);\n        setBrowserStorageItemsCount(func, 0);\n        return;\n    }\n    const minTime = Math.floor(Date.now() / browserStorageHour) - browserStorageCacheExpiration;\n    const parseItem = (index)=>{\n        const name = browserCachePrefix + index.toString();\n        const item = getStoredItem(func, name);\n        if (typeof item !== \"string\") {\n            return;\n        }\n        try {\n            const data = JSON.parse(item);\n            if (typeof data === \"object\" && typeof data.cached === \"number\" && data.cached > minTime && typeof data.provider === \"string\" && typeof data.data === \"object\" && typeof data.data.prefix === \"string\" && // Valid item: run callback\n            callback(data, index)) {\n                return true;\n            }\n        } catch (err) {}\n        removeStoredItem(func, name);\n    };\n    let total = getBrowserStorageItemsCount(func);\n    for(let i = total - 1; i >= 0; i--){\n        if (!parseItem(i)) {\n            if (i === total - 1) {\n                total--;\n                setBrowserStorageItemsCount(func, total);\n            } else {\n                browserStorageEmptyItems[key].add(i);\n            }\n        }\n    }\n}\nfunction initBrowserStorage() {\n    if (browserStorageStatus) {\n        return;\n    }\n    setBrowserStorageStatus(true);\n    for(const key in browserStorageConfig){\n        iterateBrowserStorage(key, (item)=>{\n            const iconSet = item.data;\n            const provider = item.provider;\n            const prefix = iconSet.prefix;\n            const storage = getStorage(provider, prefix);\n            if (!addIconSet(storage, iconSet).length) {\n                return false;\n            }\n            const lastModified = iconSet.lastModified || -1;\n            storage.lastModifiedCached = storage.lastModifiedCached ? Math.min(storage.lastModifiedCached, lastModified) : lastModified;\n            return true;\n        });\n    }\n}\nfunction updateLastModified(storage, lastModified) {\n    const lastValue = storage.lastModifiedCached;\n    if (// Matches or newer\n    lastValue && lastValue >= lastModified) {\n        return lastValue === lastModified;\n    }\n    storage.lastModifiedCached = lastModified;\n    if (lastValue) {\n        for(const key in browserStorageConfig){\n            iterateBrowserStorage(key, (item)=>{\n                const iconSet = item.data;\n                return item.provider !== storage.provider || iconSet.prefix !== storage.prefix || iconSet.lastModified === lastModified;\n            });\n        }\n    }\n    return true;\n}\nfunction storeInBrowserStorage(storage, data) {\n    if (!browserStorageStatus) {\n        initBrowserStorage();\n    }\n    function store(key) {\n        let func;\n        if (!browserStorageConfig[key] || !(func = getBrowserStorage(key))) {\n            return;\n        }\n        const set = browserStorageEmptyItems[key];\n        let index;\n        if (set.size) {\n            set.delete(index = Array.from(set).shift());\n        } else {\n            index = getBrowserStorageItemsCount(func);\n            if (!setBrowserStorageItemsCount(func, index + 1)) {\n                return;\n            }\n        }\n        const item = {\n            cached: Math.floor(Date.now() / browserStorageHour),\n            provider: storage.provider,\n            data\n        };\n        return setStoredItem(func, browserCachePrefix + index.toString(), JSON.stringify(item));\n    }\n    if (data.lastModified && !updateLastModified(storage, data.lastModified)) {\n        return;\n    }\n    if (!Object.keys(data.icons).length) {\n        return;\n    }\n    if (data.not_found) {\n        data = Object.assign({}, data);\n        delete data.not_found;\n    }\n    if (!store(\"local\")) {\n        store(\"session\");\n    }\n}\nfunction emptyCallback() {}\nfunction loadedNewIcons(storage) {\n    if (!storage.iconsLoaderFlag) {\n        storage.iconsLoaderFlag = true;\n        setTimeout(()=>{\n            storage.iconsLoaderFlag = false;\n            updateCallbacks(storage);\n        });\n    }\n}\nfunction loadNewIcons(storage, icons) {\n    if (!storage.iconsToLoad) {\n        storage.iconsToLoad = icons;\n    } else {\n        storage.iconsToLoad = storage.iconsToLoad.concat(icons).sort();\n    }\n    if (!storage.iconsQueueFlag) {\n        storage.iconsQueueFlag = true;\n        setTimeout(()=>{\n            storage.iconsQueueFlag = false;\n            const { provider, prefix } = storage;\n            const icons2 = storage.iconsToLoad;\n            delete storage.iconsToLoad;\n            let api;\n            if (!icons2 || !(api = getAPIModule(provider))) {\n                return;\n            }\n            const params = api.prepare(provider, prefix, icons2);\n            params.forEach((item)=>{\n                sendAPIQuery(provider, item, (data)=>{\n                    if (typeof data !== \"object\") {\n                        item.icons.forEach((name)=>{\n                            storage.missing.add(name);\n                        });\n                    } else {\n                        try {\n                            const parsed = addIconSet(storage, data);\n                            if (!parsed.length) {\n                                return;\n                            }\n                            const pending = storage.pendingIcons;\n                            if (pending) {\n                                parsed.forEach((name)=>{\n                                    pending.delete(name);\n                                });\n                            }\n                            storeInBrowserStorage(storage, data);\n                        } catch (err) {\n                            console.error(err);\n                        }\n                    }\n                    loadedNewIcons(storage);\n                });\n            });\n        });\n    }\n}\nconst loadIcons$1 = (icons, callback)=>{\n    const cleanedIcons = listToIcons(icons, true, allowSimpleNames());\n    const sortedIcons = sortIcons(cleanedIcons);\n    if (!sortedIcons.pending.length) {\n        let callCallback = true;\n        if (callback) {\n            setTimeout(()=>{\n                if (callCallback) {\n                    callback(sortedIcons.loaded, sortedIcons.missing, sortedIcons.pending, emptyCallback);\n                }\n            });\n        }\n        return ()=>{\n            callCallback = false;\n        };\n    }\n    const newIcons = /* @__PURE__ */ Object.create(null);\n    const sources = [];\n    let lastProvider, lastPrefix;\n    sortedIcons.pending.forEach((icon)=>{\n        const { provider, prefix } = icon;\n        if (prefix === lastPrefix && provider === lastProvider) {\n            return;\n        }\n        lastProvider = provider;\n        lastPrefix = prefix;\n        sources.push(getStorage(provider, prefix));\n        const providerNewIcons = newIcons[provider] || (newIcons[provider] = /* @__PURE__ */ Object.create(null));\n        if (!providerNewIcons[prefix]) {\n            providerNewIcons[prefix] = [];\n        }\n    });\n    sortedIcons.pending.forEach((icon)=>{\n        const { provider, prefix, name } = icon;\n        const storage = getStorage(provider, prefix);\n        const pendingQueue = storage.pendingIcons || (storage.pendingIcons = /* @__PURE__ */ new Set());\n        if (!pendingQueue.has(name)) {\n            pendingQueue.add(name);\n            newIcons[provider][prefix].push(name);\n        }\n    });\n    sources.forEach((storage)=>{\n        const { provider, prefix } = storage;\n        if (newIcons[provider][prefix].length) {\n            loadNewIcons(storage, newIcons[provider][prefix]);\n        }\n    });\n    return callback ? storeCallback(callback, sortedIcons, sources) : emptyCallback;\n};\nconst loadIcon$1 = (icon)=>{\n    return new Promise((fulfill, reject)=>{\n        const iconObj = typeof icon === \"string\" ? stringToIcon(icon, true) : icon;\n        if (!iconObj) {\n            reject(icon);\n            return;\n        }\n        loadIcons$1([\n            iconObj || icon\n        ], (loaded)=>{\n            if (loaded.length && iconObj) {\n                const data = getIconData(iconObj);\n                if (data) {\n                    fulfill({\n                        ...defaultIconProps,\n                        ...data\n                    });\n                    return;\n                }\n            }\n            reject(icon);\n        });\n    });\n};\n/**\n * Test icon string\n */ function testIconObject(value) {\n    try {\n        const obj = typeof value === \"string\" ? JSON.parse(value) : value;\n        if (typeof obj.body === \"string\") {\n            return {\n                ...obj\n            };\n        }\n    } catch (err) {\n    //\n    }\n}\n/**\n * Parse icon value, load if needed\n */ function parseIconValue(value, onload) {\n    // Check if icon name is valid\n    const name = typeof value === \"string\" ? stringToIcon(value, true, true) : null;\n    if (!name) {\n        // Test for serialised object\n        const data = testIconObject(value);\n        return {\n            value,\n            data\n        };\n    }\n    // Valid icon name: check if data is available\n    const data = getIconData(name);\n    // Icon data exists or icon has no prefix. Do not load icon from API if icon has no prefix\n    if (data !== void 0 || !name.prefix) {\n        return {\n            value,\n            name,\n            data\n        };\n    }\n    // Load icon\n    const loading = loadIcons$1([\n        name\n    ], ()=>onload(value, name, getIconData(name)));\n    return {\n        value,\n        name,\n        loading\n    };\n}\n/**\n * Check for inline\n */ function getInline(node) {\n    return node.hasAttribute(\"inline\");\n}\n// Check for Safari\nlet isBuggedSafari = false;\ntry {\n    isBuggedSafari = navigator.vendor.indexOf(\"Apple\") === 0;\n} catch (err) {\n//\n}\n/**\n * Get render mode\n */ function getRenderMode(body, mode) {\n    switch(mode){\n        // Force mode\n        case \"svg\":\n        case \"bg\":\n        case \"mask\":\n            return mode;\n    }\n    // Check for animation, use 'style' for animated icons, unless browser is Safari\n    // (only <a>, which should be ignored or animations start with '<a')\n    if (mode !== \"style\" && (isBuggedSafari || body.indexOf(\"<a\") === -1)) {\n        // Render <svg>\n        return \"svg\";\n    }\n    // Use background or mask\n    return body.indexOf(\"currentColor\") === -1 ? \"bg\" : \"mask\";\n}\nconst unitsSplit = /(-?[0-9.]*[0-9]+[0-9.]*)/g;\nconst unitsTest = /^-?[0-9.]*[0-9]+[0-9.]*$/g;\nfunction calculateSize$1(size, ratio, precision) {\n    if (ratio === 1) {\n        return size;\n    }\n    precision = precision || 100;\n    if (typeof size === \"number\") {\n        return Math.ceil(size * ratio * precision) / precision;\n    }\n    if (typeof size !== \"string\") {\n        return size;\n    }\n    const oldParts = size.split(unitsSplit);\n    if (oldParts === null || !oldParts.length) {\n        return size;\n    }\n    const newParts = [];\n    let code = oldParts.shift();\n    let isNumber = unitsTest.test(code);\n    while(true){\n        if (isNumber) {\n            const num = parseFloat(code);\n            if (isNaN(num)) {\n                newParts.push(code);\n            } else {\n                newParts.push(Math.ceil(num * ratio * precision) / precision);\n            }\n        } else {\n            newParts.push(code);\n        }\n        code = oldParts.shift();\n        if (code === void 0) {\n            return newParts.join(\"\");\n        }\n        isNumber = !isNumber;\n    }\n}\nconst isUnsetKeyword = (value)=>value === \"unset\" || value === \"undefined\" || value === \"none\";\nfunction iconToSVG(icon, customisations) {\n    const fullIcon = {\n        ...defaultIconProps,\n        ...icon\n    };\n    const fullCustomisations = {\n        ...defaultIconCustomisations,\n        ...customisations\n    };\n    const box = {\n        left: fullIcon.left,\n        top: fullIcon.top,\n        width: fullIcon.width,\n        height: fullIcon.height\n    };\n    let body = fullIcon.body;\n    [\n        fullIcon,\n        fullCustomisations\n    ].forEach((props)=>{\n        const transformations = [];\n        const hFlip = props.hFlip;\n        const vFlip = props.vFlip;\n        let rotation = props.rotate;\n        if (hFlip) {\n            if (vFlip) {\n                rotation += 2;\n            } else {\n                transformations.push(\"translate(\" + (box.width + box.left).toString() + \" \" + (0 - box.top).toString() + \")\");\n                transformations.push(\"scale(-1 1)\");\n                box.top = box.left = 0;\n            }\n        } else if (vFlip) {\n            transformations.push(\"translate(\" + (0 - box.left).toString() + \" \" + (box.height + box.top).toString() + \")\");\n            transformations.push(\"scale(1 -1)\");\n            box.top = box.left = 0;\n        }\n        let tempValue;\n        if (rotation < 0) {\n            rotation -= Math.floor(rotation / 4) * 4;\n        }\n        rotation = rotation % 4;\n        switch(rotation){\n            case 1:\n                tempValue = box.height / 2 + box.top;\n                transformations.unshift(\"rotate(90 \" + tempValue.toString() + \" \" + tempValue.toString() + \")\");\n                break;\n            case 2:\n                transformations.unshift(\"rotate(180 \" + (box.width / 2 + box.left).toString() + \" \" + (box.height / 2 + box.top).toString() + \")\");\n                break;\n            case 3:\n                tempValue = box.width / 2 + box.left;\n                transformations.unshift(\"rotate(-90 \" + tempValue.toString() + \" \" + tempValue.toString() + \")\");\n                break;\n        }\n        if (rotation % 2 === 1) {\n            if (box.left !== box.top) {\n                tempValue = box.left;\n                box.left = box.top;\n                box.top = tempValue;\n            }\n            if (box.width !== box.height) {\n                tempValue = box.width;\n                box.width = box.height;\n                box.height = tempValue;\n            }\n        }\n        if (transformations.length) {\n            body = '<g transform=\"' + transformations.join(\" \") + '\">' + body + \"</g>\";\n        }\n    });\n    const customisationsWidth = fullCustomisations.width;\n    const customisationsHeight = fullCustomisations.height;\n    const boxWidth = box.width;\n    const boxHeight = box.height;\n    let width;\n    let height;\n    if (customisationsWidth === null) {\n        height = customisationsHeight === null ? \"1em\" : customisationsHeight === \"auto\" ? boxHeight : customisationsHeight;\n        width = calculateSize$1(height, boxWidth / boxHeight);\n    } else {\n        width = customisationsWidth === \"auto\" ? boxWidth : customisationsWidth;\n        height = customisationsHeight === null ? calculateSize$1(width, boxHeight / boxWidth) : customisationsHeight === \"auto\" ? boxHeight : customisationsHeight;\n    }\n    const attributes = {};\n    const setAttr = (prop, value)=>{\n        if (!isUnsetKeyword(value)) {\n            attributes[prop] = value.toString();\n        }\n    };\n    setAttr(\"width\", width);\n    setAttr(\"height\", height);\n    attributes.viewBox = box.left.toString() + \" \" + box.top.toString() + \" \" + boxWidth.toString() + \" \" + boxHeight.toString();\n    return {\n        attributes,\n        body\n    };\n}\nconst detectFetch = ()=>{\n    let callback;\n    try {\n        callback = fetch;\n        if (typeof callback === \"function\") {\n            return callback;\n        }\n    } catch (err) {}\n};\nlet fetchModule = detectFetch();\nfunction setFetch(fetch2) {\n    fetchModule = fetch2;\n}\nfunction getFetch() {\n    return fetchModule;\n}\nfunction calculateMaxLength(provider, prefix) {\n    const config = getAPIConfig(provider);\n    if (!config) {\n        return 0;\n    }\n    let result;\n    if (!config.maxURL) {\n        result = 0;\n    } else {\n        let maxHostLength = 0;\n        config.resources.forEach((item)=>{\n            const host = item;\n            maxHostLength = Math.max(maxHostLength, host.length);\n        });\n        const url = prefix + \".json?icons=\";\n        result = config.maxURL - maxHostLength - config.path.length - url.length;\n    }\n    return result;\n}\nfunction shouldAbort(status) {\n    return status === 404;\n}\nconst prepare = (provider, prefix, icons)=>{\n    const results = [];\n    const maxLength = calculateMaxLength(provider, prefix);\n    const type = \"icons\";\n    let item = {\n        type,\n        provider,\n        prefix,\n        icons: []\n    };\n    let length = 0;\n    icons.forEach((name, index)=>{\n        length += name.length + 1;\n        if (length >= maxLength && index > 0) {\n            results.push(item);\n            item = {\n                type,\n                provider,\n                prefix,\n                icons: []\n            };\n            length = name.length;\n        }\n        item.icons.push(name);\n    });\n    results.push(item);\n    return results;\n};\nfunction getPath(provider) {\n    if (typeof provider === \"string\") {\n        const config = getAPIConfig(provider);\n        if (config) {\n            return config.path;\n        }\n    }\n    return \"/\";\n}\nconst send = (host, params, callback)=>{\n    if (!fetchModule) {\n        callback(\"abort\", 424);\n        return;\n    }\n    let path = getPath(params.provider);\n    switch(params.type){\n        case \"icons\":\n            {\n                const prefix = params.prefix;\n                const icons = params.icons;\n                const iconsList = icons.join(\",\");\n                const urlParams = new URLSearchParams({\n                    icons: iconsList\n                });\n                path += prefix + \".json?\" + urlParams.toString();\n                break;\n            }\n        case \"custom\":\n            {\n                const uri = params.uri;\n                path += uri.slice(0, 1) === \"/\" ? uri.slice(1) : uri;\n                break;\n            }\n        default:\n            callback(\"abort\", 400);\n            return;\n    }\n    let defaultError = 503;\n    fetchModule(host + path).then((response)=>{\n        const status = response.status;\n        if (status !== 200) {\n            setTimeout(()=>{\n                callback(shouldAbort(status) ? \"abort\" : \"next\", status);\n            });\n            return;\n        }\n        defaultError = 501;\n        return response.json();\n    }).then((data)=>{\n        if (typeof data !== \"object\" || data === null) {\n            setTimeout(()=>{\n                if (data === 404) {\n                    callback(\"abort\", data);\n                } else {\n                    callback(\"next\", defaultError);\n                }\n            });\n            return;\n        }\n        setTimeout(()=>{\n            callback(\"success\", data);\n        });\n    }).catch(()=>{\n        callback(\"next\", defaultError);\n    });\n};\nconst fetchAPIModule = {\n    prepare,\n    send\n};\nfunction toggleBrowserCache(storage, value) {\n    switch(storage){\n        case \"local\":\n        case \"session\":\n            browserStorageConfig[storage] = value;\n            break;\n        case \"all\":\n            for(const key in browserStorageConfig){\n                browserStorageConfig[key] = value;\n            }\n            break;\n    }\n}\n/**\n * Attribute to add\n */ const nodeAttr = \"data-style\";\n/**\n * Custom style to add to each node\n */ let customStyle = \"\";\n/**\n * Set custom style to add to all components\n *\n * Affects only components rendered after function call\n */ function appendCustomStyle(style) {\n    customStyle = style;\n}\n/**\n * Add/update style node\n */ function updateStyle(parent, inline) {\n    // Get node, create if needed\n    let styleNode = Array.from(parent.childNodes).find((node)=>node.hasAttribute && node.hasAttribute(nodeAttr));\n    if (!styleNode) {\n        styleNode = document.createElement(\"style\");\n        styleNode.setAttribute(nodeAttr, nodeAttr);\n        parent.appendChild(styleNode);\n    }\n    // Update content\n    styleNode.textContent = \":host{display:inline-block;vertical-align:\" + (inline ? \"-0.125em\" : \"0\") + \"}span,svg{display:block}\" + customStyle;\n}\n// Core\n/**\n * Get functions and initialise stuff\n */ function exportFunctions() {\n    /**\n     * Initialise stuff\n     */ // Set API module\n    setAPIModule(\"\", fetchAPIModule);\n    // Allow simple icon names\n    allowSimpleNames(true);\n    let _window;\n    try {\n        _window = window;\n    } catch (err) {\n    //\n    }\n    if (_window) {\n        // Set cache and load existing cache\n        initBrowserStorage();\n        // Load icons from global \"IconifyPreload\"\n        if (_window.IconifyPreload !== void 0) {\n            const preload = _window.IconifyPreload;\n            const err = \"Invalid IconifyPreload syntax.\";\n            if (typeof preload === \"object\" && preload !== null) {\n                (preload instanceof Array ? preload : [\n                    preload\n                ]).forEach((item)=>{\n                    try {\n                        if (// Check if item is an object and not null/array\n                        typeof item !== \"object\" || item === null || item instanceof Array || // Check for 'icons' and 'prefix'\n                        typeof item.icons !== \"object\" || typeof item.prefix !== \"string\" || // Add icon set\n                        !addCollection$1(item)) {\n                            console.error(err);\n                        }\n                    } catch (e) {\n                        console.error(err);\n                    }\n                });\n            }\n        }\n        // Set API from global \"IconifyProviders\"\n        if (_window.IconifyProviders !== void 0) {\n            const providers = _window.IconifyProviders;\n            if (typeof providers === \"object\" && providers !== null) {\n                for(const key in providers){\n                    const err = \"IconifyProviders[\" + key + \"] is invalid.\";\n                    try {\n                        const value = providers[key];\n                        if (typeof value !== \"object\" || !value || value.resources === void 0) {\n                            continue;\n                        }\n                        if (!addAPIProvider$1(key, value)) {\n                            console.error(err);\n                        }\n                    } catch (e) {\n                        console.error(err);\n                    }\n                }\n            }\n        }\n    }\n    const _api = {\n        getAPIConfig,\n        setAPIModule,\n        sendAPIQuery,\n        setFetch,\n        getFetch,\n        listAPIProviders\n    };\n    return {\n        enableCache: (storage)=>toggleBrowserCache(storage, true),\n        disableCache: (storage)=>toggleBrowserCache(storage, false),\n        iconExists: iconExists$1,\n        getIcon: getIcon$1,\n        listIcons: listIcons$1,\n        addIcon: addIcon$1,\n        addCollection: addCollection$1,\n        calculateSize: calculateSize$1,\n        buildIcon: iconToSVG,\n        loadIcons: loadIcons$1,\n        loadIcon: loadIcon$1,\n        addAPIProvider: addAPIProvider$1,\n        appendCustomStyle,\n        _api\n    };\n}\nfunction iconToHTML(body, attributes) {\n    let renderAttribsHTML = body.indexOf(\"xlink:\") === -1 ? \"\" : ' xmlns:xlink=\"http://www.w3.org/1999/xlink\"';\n    for(const attr in attributes){\n        renderAttribsHTML += \" \" + attr + '=\"' + attributes[attr] + '\"';\n    }\n    return '<svg xmlns=\"http://www.w3.org/2000/svg\"' + renderAttribsHTML + \">\" + body + \"</svg>\";\n}\nfunction encodeSVGforURL(svg) {\n    return svg.replace(/\"/g, \"'\").replace(/%/g, \"%25\").replace(/#/g, \"%23\").replace(/</g, \"%3C\").replace(/>/g, \"%3E\").replace(/\\s+/g, \" \");\n}\nfunction svgToData(svg) {\n    return \"data:image/svg+xml,\" + encodeSVGforURL(svg);\n}\nfunction svgToURL(svg) {\n    return 'url(\"' + svgToData(svg) + '\")';\n}\n// List of properties to apply\nconst monotoneProps = {\n    \"background-color\": \"currentColor\"\n};\nconst coloredProps = {\n    \"background-color\": \"transparent\"\n};\n// Dynamically add common props to variables above\nconst propsToAdd = {\n    image: \"var(--svg)\",\n    repeat: \"no-repeat\",\n    size: \"100% 100%\"\n};\nconst propsToAddTo = {\n    \"-webkit-mask\": monotoneProps,\n    \"mask\": monotoneProps,\n    \"background\": coloredProps\n};\nfor(const prefix in propsToAddTo){\n    const list = propsToAddTo[prefix];\n    for(const prop in propsToAdd){\n        list[prefix + \"-\" + prop] = propsToAdd[prop];\n    }\n}\n/**\n * Fix size: add 'px' to numbers\n */ function fixSize(value) {\n    return value ? value + (value.match(/^[-0-9.]+$/) ? \"px\" : \"\") : \"inherit\";\n}\n/**\n * Render node as <span>\n */ function renderSPAN(data, icon, useMask) {\n    const node = document.createElement(\"span\");\n    // Body\n    let body = data.body;\n    if (body.indexOf(\"<a\") !== -1) {\n        // Animated SVG: add something to fix timing bug\n        body += \"<!-- \" + Date.now() + \" -->\";\n    }\n    // Generate SVG as URL\n    const renderAttribs = data.attributes;\n    const html = iconToHTML(body, {\n        ...renderAttribs,\n        width: icon.width + \"\",\n        height: icon.height + \"\"\n    });\n    const url = svgToURL(html);\n    // Generate style\n    const svgStyle = node.style;\n    const styles = {\n        \"--svg\": url,\n        \"width\": fixSize(renderAttribs.width),\n        \"height\": fixSize(renderAttribs.height),\n        ...useMask ? monotoneProps : coloredProps\n    };\n    // Apply style\n    for(const prop in styles){\n        svgStyle.setProperty(prop, styles[prop]);\n    }\n    return node;\n}\nlet policy;\nfunction createPolicy() {\n    try {\n        policy = window.trustedTypes.createPolicy(\"iconify\", {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-return\n            createHTML: (s)=>s\n        });\n    } catch (err) {\n        policy = null;\n    }\n}\nfunction cleanUpInnerHTML(html) {\n    if (policy === void 0) {\n        createPolicy();\n    }\n    return policy ? policy.createHTML(html) : html;\n}\n/**\n * Render node as <svg>\n */ function renderSVG(data) {\n    const node = document.createElement(\"span\");\n    // Add style if needed\n    const attr = data.attributes;\n    let style = \"\";\n    if (!attr.width) {\n        style = \"width: inherit;\";\n    }\n    if (!attr.height) {\n        style += \"height: inherit;\";\n    }\n    if (style) {\n        attr.style = style;\n    }\n    // Generate SVG\n    const html = iconToHTML(data.body, attr);\n    node.innerHTML = cleanUpInnerHTML(html);\n    return node.firstChild;\n}\n/**\n * Render icon\n */ function renderIcon(parent, state) {\n    const iconData = state.icon.data;\n    const customisations = state.customisations;\n    // Render icon\n    const renderData = iconToSVG(iconData, customisations);\n    if (customisations.preserveAspectRatio) {\n        renderData.attributes[\"preserveAspectRatio\"] = customisations.preserveAspectRatio;\n    }\n    const mode = state.renderedMode;\n    let node;\n    switch(mode){\n        case \"svg\":\n            node = renderSVG(renderData);\n            break;\n        default:\n            node = renderSPAN(renderData, {\n                ...defaultIconProps,\n                ...iconData\n            }, mode === \"mask\");\n    }\n    // Set element\n    const oldNode = Array.from(parent.childNodes).find((node)=>{\n        const tag = node.tagName && node.tagName.toUpperCase();\n        return tag === \"SPAN\" || tag === \"SVG\";\n    });\n    if (oldNode) {\n        // Replace old element\n        if (node.tagName === \"SPAN\" && oldNode.tagName === node.tagName) {\n            // Swap style instead of whole node\n            oldNode.setAttribute(\"style\", node.getAttribute(\"style\"));\n        } else {\n            parent.replaceChild(node, oldNode);\n        }\n    } else {\n        // Add new element\n        parent.appendChild(node);\n    }\n}\n/**\n * Set state to PendingState\n */ function setPendingState(icon, inline, lastState) {\n    const lastRender = lastState && (lastState.rendered ? lastState : lastState.lastRender);\n    return {\n        rendered: false,\n        inline,\n        icon,\n        lastRender\n    };\n}\n/**\n * Register 'iconify-icon' component, if it does not exist\n */ function defineIconifyIcon(name = \"iconify-icon\") {\n    // Check for custom elements registry and HTMLElement\n    let customElements;\n    let ParentClass;\n    try {\n        customElements = window.customElements;\n        ParentClass = window.HTMLElement;\n    } catch (err) {\n        return;\n    }\n    // Make sure registry and HTMLElement exist\n    if (!customElements || !ParentClass) {\n        return;\n    }\n    // Check for duplicate\n    const ConflictingClass = customElements.get(name);\n    if (ConflictingClass) {\n        return ConflictingClass;\n    }\n    // All attributes\n    const attributes = [\n        // Icon\n        \"icon\",\n        // Mode\n        \"mode\",\n        \"inline\",\n        // Customisations\n        \"width\",\n        \"height\",\n        \"rotate\",\n        \"flip\"\n    ];\n    /**\n     * Component class\n     */ const IconifyIcon = class extends ParentClass {\n        /**\n         * Constructor\n         */ constructor(){\n            super();\n            // Attributes check queued\n            this._checkQueued = false;\n            // Attach shadow DOM\n            const root = this._shadowRoot = this.attachShadow({\n                mode: \"open\"\n            });\n            // Add style\n            const inline = getInline(this);\n            updateStyle(root, inline);\n            // Create empty state\n            this._state = setPendingState({\n                value: \"\"\n            }, inline);\n            // Queue icon render\n            this._queueCheck();\n        }\n        /**\n         * Observed attributes\n         */ static get observedAttributes() {\n            return attributes.slice(0);\n        }\n        /**\n         * Observed properties that are different from attributes\n         *\n         * Experimental! Need to test with various frameworks that support it\n         */ /*\n        static get properties() {\n            return {\n                inline: {\n                    type: Boolean,\n                    reflect: true,\n                },\n                // Not listing other attributes because they are strings or combination\n                // of string and another type. Cannot have multiple types\n            };\n        }\n        */ /**\n         * Attribute has changed\n         */ attributeChangedCallback(name) {\n            if (name === \"inline\") {\n                // Update immediately: not affected by other attributes\n                const newInline = getInline(this);\n                const state = this._state;\n                if (newInline !== state.inline) {\n                    // Update style if inline mode changed\n                    state.inline = newInline;\n                    updateStyle(this._shadowRoot, newInline);\n                }\n            } else {\n                // Queue check for other attributes\n                this._queueCheck();\n            }\n        }\n        /**\n         * Get/set icon\n         */ get icon() {\n            const value = this.getAttribute(\"icon\");\n            if (value && value.slice(0, 1) === \"{\") {\n                try {\n                    return JSON.parse(value);\n                } catch (err) {\n                //\n                }\n            }\n            return value;\n        }\n        set icon(value) {\n            if (typeof value === \"object\") {\n                value = JSON.stringify(value);\n            }\n            this.setAttribute(\"icon\", value);\n        }\n        /**\n         * Get/set inline\n         */ get inline() {\n            return getInline(this);\n        }\n        set inline(value) {\n            if (value) {\n                this.setAttribute(\"inline\", \"true\");\n            } else {\n                this.removeAttribute(\"inline\");\n            }\n        }\n        /**\n         * Restart animation\n         */ restartAnimation() {\n            const state = this._state;\n            if (state.rendered) {\n                const root = this._shadowRoot;\n                if (state.renderedMode === \"svg\") {\n                    // Update root node\n                    try {\n                        root.lastChild.setCurrentTime(0);\n                        return;\n                    } catch (err) {\n                    // Failed: setCurrentTime() is not supported\n                    }\n                }\n                renderIcon(root, state);\n            }\n        }\n        /**\n         * Get status\n         */ get status() {\n            const state = this._state;\n            return state.rendered ? \"rendered\" : state.icon.data === null ? \"failed\" : \"loading\";\n        }\n        /**\n         * Queue attributes re-check\n         */ _queueCheck() {\n            if (!this._checkQueued) {\n                this._checkQueued = true;\n                setTimeout(()=>{\n                    this._check();\n                });\n            }\n        }\n        /**\n         * Check for changes\n         */ _check() {\n            if (!this._checkQueued) {\n                return;\n            }\n            this._checkQueued = false;\n            const state = this._state;\n            // Get icon\n            const newIcon = this.getAttribute(\"icon\");\n            if (newIcon !== state.icon.value) {\n                this._iconChanged(newIcon);\n                return;\n            }\n            // Ignore other attributes if icon is not rendered\n            if (!state.rendered) {\n                return;\n            }\n            // Check for mode and attribute changes\n            const mode = this.getAttribute(\"mode\");\n            const customisations = getCustomisations(this);\n            if (state.attrMode !== mode || haveCustomisationsChanged(state.customisations, customisations)) {\n                this._renderIcon(state.icon, customisations, mode);\n            }\n        }\n        /**\n         * Icon value has changed\n         */ _iconChanged(newValue) {\n            const icon = parseIconValue(newValue, (value, name, data)=>{\n                // Asynchronous callback: re-check values to make sure stuff wasn't changed\n                const state = this._state;\n                if (state.rendered || this.getAttribute(\"icon\") !== value) {\n                    // Icon data is already available or icon attribute was changed\n                    return;\n                }\n                // Change icon\n                const icon = {\n                    value,\n                    name,\n                    data\n                };\n                if (icon.data) {\n                    // Render icon\n                    this._gotIconData(icon);\n                } else {\n                    // Nothing to render: update icon in state\n                    state.icon = icon;\n                }\n            });\n            if (icon.data) {\n                // Icon is ready to render\n                this._gotIconData(icon);\n            } else {\n                // Pending icon\n                this._state = setPendingState(icon, this._state.inline, this._state);\n            }\n        }\n        /**\n         * Got new icon data, icon is ready to (re)render\n         */ _gotIconData(icon) {\n            this._checkQueued = false;\n            this._renderIcon(icon, getCustomisations(this), this.getAttribute(\"mode\"));\n        }\n        /**\n         * Re-render based on icon data\n         */ _renderIcon(icon, customisations, attrMode) {\n            // Get mode\n            const renderedMode = getRenderMode(icon.data.body, attrMode);\n            // Inline was not changed\n            const inline = this._state.inline;\n            // Set state and render\n            renderIcon(this._shadowRoot, this._state = {\n                rendered: true,\n                icon,\n                inline,\n                customisations,\n                attrMode,\n                renderedMode\n            });\n        }\n    };\n    // Add getters and setters\n    attributes.forEach((attr)=>{\n        if (!(attr in IconifyIcon.prototype)) {\n            Object.defineProperty(IconifyIcon.prototype, attr, {\n                get: function() {\n                    return this.getAttribute(attr);\n                },\n                set: function(value) {\n                    if (value !== null) {\n                        this.setAttribute(attr, value);\n                    } else {\n                        this.removeAttribute(attr);\n                    }\n                }\n            });\n        }\n    });\n    // Add exported functions: both as static and instance methods\n    const functions = exportFunctions();\n    for(const key in functions){\n        IconifyIcon[key] = IconifyIcon.prototype[key] = functions[key];\n    }\n    // Define new component\n    customElements.define(name, IconifyIcon);\n    return IconifyIcon;\n}\n/**\n * Create exported data: either component instance or functions\n */ const IconifyIconComponent = defineIconifyIcon() || exportFunctions();\n/**\n * Export functions\n */ const { enableCache, disableCache, iconExists, getIcon, listIcons, addIcon, addCollection, calculateSize, buildIcon, loadIcons, loadIcon, addAPIProvider, _api } = IconifyIconComponent;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vaWNvbmlmeS1pY29uQDEuMC44L25vZGVfbW9kdWxlcy9pY29uaWZ5LWljb24vZGlzdC9pY29uaWZ5LWljb24ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBOzs7Ozs7Ozs7O0FBVUEsR0FDQSxNQUFNQSx3QkFBd0JDLE9BQU9DLE1BQU0sQ0FDekM7SUFDRUMsTUFBTTtJQUNOQyxLQUFLO0lBQ0xDLE9BQU87SUFDUEMsUUFBUTtBQUNWO0FBRUYsTUFBTUMsNkJBQTZCTixPQUFPQyxNQUFNLENBQUM7SUFDL0NNLFFBQVE7SUFDUkMsT0FBTztJQUNQQyxPQUFPO0FBQ1Q7QUFDQSxNQUFNQyxtQkFBbUJWLE9BQU9DLE1BQU0sQ0FBQztJQUNyQyxHQUFHRixxQkFBcUI7SUFDeEIsR0FBR08sMEJBQTBCO0FBQy9CO0FBQ0EsTUFBTUssMkJBQTJCWCxPQUFPQyxNQUFNLENBQUM7SUFDN0MsR0FBR1MsZ0JBQWdCO0lBQ25CRSxNQUFNO0lBQ05DLFFBQVE7QUFDVjtBQUVBLE1BQU1DLGdDQUFnQ2QsT0FBT0MsTUFBTSxDQUFDO0lBQ2xERyxPQUFPO0lBQ1BDLFFBQVE7QUFDVjtBQUNBLE1BQU1VLDRCQUE0QmYsT0FBT0MsTUFBTSxDQUFDO0lBQzlDLGFBQWE7SUFDYixHQUFHYSw2QkFBNkI7SUFDaEMsa0JBQWtCO0lBQ2xCLEdBQUdSLDBCQUEwQjtBQUMvQjtBQUVBLFNBQVNVLGlCQUFpQkMsS0FBSyxFQUFFQyxlQUFlLENBQUM7SUFDL0MsTUFBTUMsUUFBUUYsTUFBTUcsT0FBTyxDQUFDLGNBQWM7SUFDMUMsU0FBU0MsUUFBUUMsTUFBTTtRQUNyQixNQUFPQSxTQUFTLEVBQUc7WUFDakJBLFVBQVU7UUFDWjtRQUNBLE9BQU9BLFNBQVM7SUFDbEI7SUFDQSxJQUFJSCxVQUFVLElBQUk7UUFDaEIsTUFBTUksTUFBTUMsU0FBU1A7UUFDckIsT0FBT1EsTUFBTUYsT0FBTyxJQUFJRixRQUFRRTtJQUNsQyxP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QUFPLEVBQUVDLGFBQWEsRUFBRUMsYUFBYSxFQUFFQyxTQUFTLEVBQUVDLFNBQVMsRUFBRUMsUUFBUSxFQUFFQyxjQUFjLEVBQUVaLElBQUksRUFBRyxHQUFHd0Y7QUFFdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hbGwtaW4tb25lLWlucy8uL25vZGVfbW9kdWxlcy8ucG5wbS9pY29uaWZ5LWljb25AMS4wLjgvbm9kZV9tb2R1bGVzL2ljb25pZnktaWNvbi9kaXN0L2ljb25pZnktaWNvbi5tanM/NjFlNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiogKGMpIEljb25pZnlcbipcbiogRm9yIHRoZSBmdWxsIGNvcHlyaWdodCBhbmQgbGljZW5zZSBpbmZvcm1hdGlvbiwgcGxlYXNlIHZpZXcgdGhlIGxpY2Vuc2UudHh0XG4qIGZpbGVzIGF0IGh0dHBzOi8vZ2l0aHViLmNvbS9pY29uaWZ5L2ljb25pZnlcbipcbiogTGljZW5zZWQgdW5kZXIgTUlULlxuKlxuKiBAbGljZW5zZSBNSVRcbiogQHZlcnNpb24gMS4wLjhcbiovXG5jb25zdCBkZWZhdWx0SWNvbkRpbWVuc2lvbnMgPSBPYmplY3QuZnJlZXplKFxuICB7XG4gICAgbGVmdDogMCxcbiAgICB0b3A6IDAsXG4gICAgd2lkdGg6IDE2LFxuICAgIGhlaWdodDogMTZcbiAgfVxuKTtcbmNvbnN0IGRlZmF1bHRJY29uVHJhbnNmb3JtYXRpb25zID0gT2JqZWN0LmZyZWV6ZSh7XG4gIHJvdGF0ZTogMCxcbiAgdkZsaXA6IGZhbHNlLFxuICBoRmxpcDogZmFsc2Vcbn0pO1xuY29uc3QgZGVmYXVsdEljb25Qcm9wcyA9IE9iamVjdC5mcmVlemUoe1xuICAuLi5kZWZhdWx0SWNvbkRpbWVuc2lvbnMsXG4gIC4uLmRlZmF1bHRJY29uVHJhbnNmb3JtYXRpb25zXG59KTtcbmNvbnN0IGRlZmF1bHRFeHRlbmRlZEljb25Qcm9wcyA9IE9iamVjdC5mcmVlemUoe1xuICAuLi5kZWZhdWx0SWNvblByb3BzLFxuICBib2R5OiBcIlwiLFxuICBoaWRkZW46IGZhbHNlXG59KTtcblxuY29uc3QgZGVmYXVsdEljb25TaXplQ3VzdG9taXNhdGlvbnMgPSBPYmplY3QuZnJlZXplKHtcbiAgd2lkdGg6IG51bGwsXG4gIGhlaWdodDogbnVsbFxufSk7XG5jb25zdCBkZWZhdWx0SWNvbkN1c3RvbWlzYXRpb25zID0gT2JqZWN0LmZyZWV6ZSh7XG4gIC8vIERpbWVuc2lvbnNcbiAgLi4uZGVmYXVsdEljb25TaXplQ3VzdG9taXNhdGlvbnMsXG4gIC8vIFRyYW5zZm9ybWF0aW9uc1xuICAuLi5kZWZhdWx0SWNvblRyYW5zZm9ybWF0aW9uc1xufSk7XG5cbmZ1bmN0aW9uIHJvdGF0ZUZyb21TdHJpbmcodmFsdWUsIGRlZmF1bHRWYWx1ZSA9IDApIHtcbiAgY29uc3QgdW5pdHMgPSB2YWx1ZS5yZXBsYWNlKC9eLT9bMC05Ll0qLywgXCJcIik7XG4gIGZ1bmN0aW9uIGNsZWFudXAodmFsdWUyKSB7XG4gICAgd2hpbGUgKHZhbHVlMiA8IDApIHtcbiAgICAgIHZhbHVlMiArPSA0O1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUyICUgNDtcbiAgfVxuICBpZiAodW5pdHMgPT09IFwiXCIpIHtcbiAgICBjb25zdCBudW0gPSBwYXJzZUludCh2YWx1ZSk7XG4gICAgcmV0dXJuIGlzTmFOKG51bSkgPyAwIDogY2xlYW51cChudW0pO1xuICB9IGVsc2UgaWYgKHVuaXRzICE9PSB2YWx1ZSkge1xuICAgIGxldCBzcGxpdCA9IDA7XG4gICAgc3dpdGNoICh1bml0cykge1xuICAgICAgY2FzZSBcIiVcIjpcbiAgICAgICAgc3BsaXQgPSAyNTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGVnXCI6XG4gICAgICAgIHNwbGl0ID0gOTA7XG4gICAgfVxuICAgIGlmIChzcGxpdCkge1xuICAgICAgbGV0IG51bSA9IHBhcnNlRmxvYXQodmFsdWUuc2xpY2UoMCwgdmFsdWUubGVuZ3RoIC0gdW5pdHMubGVuZ3RoKSk7XG4gICAgICBpZiAoaXNOYU4obnVtKSkge1xuICAgICAgICByZXR1cm4gMDtcbiAgICAgIH1cbiAgICAgIG51bSA9IG51bSAvIHNwbGl0O1xuICAgICAgcmV0dXJuIG51bSAlIDEgPT09IDAgPyBjbGVhbnVwKG51bSkgOiAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVmYXVsdFZhbHVlO1xufVxuXG5jb25zdCBzZXBhcmF0b3IgPSAvW1xccyxdKy87XG5mdW5jdGlvbiBmbGlwRnJvbVN0cmluZyhjdXN0b20sIGZsaXApIHtcbiAgZmxpcC5zcGxpdChzZXBhcmF0b3IpLmZvckVhY2goKHN0cikgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gc3RyLnRyaW0oKTtcbiAgICBzd2l0Y2ggKHZhbHVlKSB7XG4gICAgICBjYXNlIFwiaG9yaXpvbnRhbFwiOlxuICAgICAgICBjdXN0b20uaEZsaXAgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ2ZXJ0aWNhbFwiOlxuICAgICAgICBjdXN0b20udkZsaXAgPSB0cnVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH0pO1xufVxuXG5jb25zdCBkZWZhdWx0Q3VzdG9taXNhdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdEljb25DdXN0b21pc2F0aW9ucyxcbiAgICBwcmVzZXJ2ZUFzcGVjdFJhdGlvOiAnJyxcbn07XG4vKipcbiAqIEdldCBjdXN0b21pc2F0aW9uc1xuICovXG5mdW5jdGlvbiBnZXRDdXN0b21pc2F0aW9ucyhub2RlKSB7XG4gICAgY29uc3QgY3VzdG9taXNhdGlvbnMgPSB7XG4gICAgICAgIC4uLmRlZmF1bHRDdXN0b21pc2F0aW9ucyxcbiAgICB9O1xuICAgIGNvbnN0IGF0dHIgPSAoa2V5LCBkZWYpID0+IG5vZGUuZ2V0QXR0cmlidXRlKGtleSkgfHwgZGVmO1xuICAgIC8vIERpbWVuc2lvbnNcbiAgICBjdXN0b21pc2F0aW9ucy53aWR0aCA9IGF0dHIoJ3dpZHRoJywgbnVsbCk7XG4gICAgY3VzdG9taXNhdGlvbnMuaGVpZ2h0ID0gYXR0cignaGVpZ2h0JywgbnVsbCk7XG4gICAgLy8gUm90YXRpb25cbiAgICBjdXN0b21pc2F0aW9ucy5yb3RhdGUgPSByb3RhdGVGcm9tU3RyaW5nKGF0dHIoJ3JvdGF0ZScsICcnKSk7XG4gICAgLy8gRmxpcFxuICAgIGZsaXBGcm9tU3RyaW5nKGN1c3RvbWlzYXRpb25zLCBhdHRyKCdmbGlwJywgJycpKTtcbiAgICAvLyBTVkcgYXR0cmlidXRlc1xuICAgIGN1c3RvbWlzYXRpb25zLnByZXNlcnZlQXNwZWN0UmF0aW8gPSBhdHRyKCdwcmVzZXJ2ZUFzcGVjdFJhdGlvJywgYXR0cigncHJlc2VydmVhc3BlY3RyYXRpbycsICcnKSk7XG4gICAgcmV0dXJuIGN1c3RvbWlzYXRpb25zO1xufVxuLyoqXG4gKiBDaGVjayBpZiBjdXN0b21pc2F0aW9ucyBoYXZlIGJlZW4gdXBkYXRlZFxuICovXG5mdW5jdGlvbiBoYXZlQ3VzdG9taXNhdGlvbnNDaGFuZ2VkKHZhbHVlMSwgdmFsdWUyKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdEN1c3RvbWlzYXRpb25zKSB7XG4gICAgICAgIGlmICh2YWx1ZTFba2V5XSAhPT0gdmFsdWUyW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuY29uc3QgbWF0Y2hJY29uTmFtZSA9IC9eW2EtejAtOV0rKC1bYS16MC05XSspKiQvO1xuY29uc3Qgc3RyaW5nVG9JY29uID0gKHZhbHVlLCB2YWxpZGF0ZSwgYWxsb3dTaW1wbGVOYW1lLCBwcm92aWRlciA9IFwiXCIpID0+IHtcbiAgY29uc3QgY29sb25TZXBhcmF0ZWQgPSB2YWx1ZS5zcGxpdChcIjpcIik7XG4gIGlmICh2YWx1ZS5zbGljZSgwLCAxKSA9PT0gXCJAXCIpIHtcbiAgICBpZiAoY29sb25TZXBhcmF0ZWQubGVuZ3RoIDwgMiB8fCBjb2xvblNlcGFyYXRlZC5sZW5ndGggPiAzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcHJvdmlkZXIgPSBjb2xvblNlcGFyYXRlZC5zaGlmdCgpLnNsaWNlKDEpO1xuICB9XG4gIGlmIChjb2xvblNlcGFyYXRlZC5sZW5ndGggPiAzIHx8ICFjb2xvblNlcGFyYXRlZC5sZW5ndGgpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoY29sb25TZXBhcmF0ZWQubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IG5hbWUyID0gY29sb25TZXBhcmF0ZWQucG9wKCk7XG4gICAgY29uc3QgcHJlZml4ID0gY29sb25TZXBhcmF0ZWQucG9wKCk7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgLy8gQWxsb3cgcHJvdmlkZXIgd2l0aG91dCAnQCc6IFwicHJvdmlkZXI6cHJlZml4Om5hbWVcIlxuICAgICAgcHJvdmlkZXI6IGNvbG9uU2VwYXJhdGVkLmxlbmd0aCA+IDAgPyBjb2xvblNlcGFyYXRlZFswXSA6IHByb3ZpZGVyLFxuICAgICAgcHJlZml4LFxuICAgICAgbmFtZTogbmFtZTJcbiAgICB9O1xuICAgIHJldHVybiB2YWxpZGF0ZSAmJiAhdmFsaWRhdGVJY29uTmFtZShyZXN1bHQpID8gbnVsbCA6IHJlc3VsdDtcbiAgfVxuICBjb25zdCBuYW1lID0gY29sb25TZXBhcmF0ZWRbMF07XG4gIGNvbnN0IGRhc2hTZXBhcmF0ZWQgPSBuYW1lLnNwbGl0KFwiLVwiKTtcbiAgaWYgKGRhc2hTZXBhcmF0ZWQubGVuZ3RoID4gMSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIHByb3ZpZGVyLFxuICAgICAgcHJlZml4OiBkYXNoU2VwYXJhdGVkLnNoaWZ0KCksXG4gICAgICBuYW1lOiBkYXNoU2VwYXJhdGVkLmpvaW4oXCItXCIpXG4gICAgfTtcbiAgICByZXR1cm4gdmFsaWRhdGUgJiYgIXZhbGlkYXRlSWNvbk5hbWUocmVzdWx0KSA/IG51bGwgOiByZXN1bHQ7XG4gIH1cbiAgaWYgKGFsbG93U2ltcGxlTmFtZSAmJiBwcm92aWRlciA9PT0gXCJcIikge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIHByb3ZpZGVyLFxuICAgICAgcHJlZml4OiBcIlwiLFxuICAgICAgbmFtZVxuICAgIH07XG4gICAgcmV0dXJuIHZhbGlkYXRlICYmICF2YWxpZGF0ZUljb25OYW1lKHJlc3VsdCwgYWxsb3dTaW1wbGVOYW1lKSA/IG51bGwgOiByZXN1bHQ7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuY29uc3QgdmFsaWRhdGVJY29uTmFtZSA9IChpY29uLCBhbGxvd1NpbXBsZU5hbWUpID0+IHtcbiAgaWYgKCFpY29uKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiAhISgoaWNvbi5wcm92aWRlciA9PT0gXCJcIiB8fCBpY29uLnByb3ZpZGVyLm1hdGNoKG1hdGNoSWNvbk5hbWUpKSAmJiAoYWxsb3dTaW1wbGVOYW1lICYmIGljb24ucHJlZml4ID09PSBcIlwiIHx8IGljb24ucHJlZml4Lm1hdGNoKG1hdGNoSWNvbk5hbWUpKSAmJiBpY29uLm5hbWUubWF0Y2gobWF0Y2hJY29uTmFtZSkpO1xufTtcblxuZnVuY3Rpb24gbWVyZ2VJY29uVHJhbnNmb3JtYXRpb25zKG9iajEsIG9iajIpIHtcbiAgY29uc3QgcmVzdWx0ID0ge307XG4gIGlmICghb2JqMS5oRmxpcCAhPT0gIW9iajIuaEZsaXApIHtcbiAgICByZXN1bHQuaEZsaXAgPSB0cnVlO1xuICB9XG4gIGlmICghb2JqMS52RmxpcCAhPT0gIW9iajIudkZsaXApIHtcbiAgICByZXN1bHQudkZsaXAgPSB0cnVlO1xuICB9XG4gIGNvbnN0IHJvdGF0ZSA9ICgob2JqMS5yb3RhdGUgfHwgMCkgKyAob2JqMi5yb3RhdGUgfHwgMCkpICUgNDtcbiAgaWYgKHJvdGF0ZSkge1xuICAgIHJlc3VsdC5yb3RhdGUgPSByb3RhdGU7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbWVyZ2VJY29uRGF0YShwYXJlbnQsIGNoaWxkKSB7XG4gIGNvbnN0IHJlc3VsdCA9IG1lcmdlSWNvblRyYW5zZm9ybWF0aW9ucyhwYXJlbnQsIGNoaWxkKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gZGVmYXVsdEV4dGVuZGVkSWNvblByb3BzKSB7XG4gICAgaWYgKGtleSBpbiBkZWZhdWx0SWNvblRyYW5zZm9ybWF0aW9ucykge1xuICAgICAgaWYgKGtleSBpbiBwYXJlbnQgJiYgIShrZXkgaW4gcmVzdWx0KSkge1xuICAgICAgICByZXN1bHRba2V5XSA9IGRlZmF1bHRJY29uVHJhbnNmb3JtYXRpb25zW2tleV07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChrZXkgaW4gY2hpbGQpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gY2hpbGRba2V5XTtcbiAgICB9IGVsc2UgaWYgKGtleSBpbiBwYXJlbnQpIHtcbiAgICAgIHJlc3VsdFtrZXldID0gcGFyZW50W2tleV07XG4gICAgfVxuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbmZ1bmN0aW9uIGdldEljb25zVHJlZShkYXRhLCBuYW1lcykge1xuICBjb25zdCBpY29ucyA9IGRhdGEuaWNvbnM7XG4gIGNvbnN0IGFsaWFzZXMgPSBkYXRhLmFsaWFzZXMgfHwgLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGNvbnN0IHJlc29sdmVkID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGZ1bmN0aW9uIHJlc29sdmUobmFtZSkge1xuICAgIGlmIChpY29uc1tuYW1lXSkge1xuICAgICAgcmV0dXJuIHJlc29sdmVkW25hbWVdID0gW107XG4gICAgfVxuICAgIGlmICghKG5hbWUgaW4gcmVzb2x2ZWQpKSB7XG4gICAgICByZXNvbHZlZFtuYW1lXSA9IG51bGw7XG4gICAgICBjb25zdCBwYXJlbnQgPSBhbGlhc2VzW25hbWVdICYmIGFsaWFzZXNbbmFtZV0ucGFyZW50O1xuICAgICAgY29uc3QgdmFsdWUgPSBwYXJlbnQgJiYgcmVzb2x2ZShwYXJlbnQpO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJlc29sdmVkW25hbWVdID0gW3BhcmVudF0uY29uY2F0KHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc29sdmVkW25hbWVdO1xuICB9XG4gIChuYW1lcyB8fCBPYmplY3Qua2V5cyhpY29ucykuY29uY2F0KE9iamVjdC5rZXlzKGFsaWFzZXMpKSkuZm9yRWFjaChyZXNvbHZlKTtcbiAgcmV0dXJuIHJlc29sdmVkO1xufVxuXG5mdW5jdGlvbiBpbnRlcm5hbEdldEljb25EYXRhKGRhdGEsIG5hbWUsIHRyZWUpIHtcbiAgY29uc3QgaWNvbnMgPSBkYXRhLmljb25zO1xuICBjb25zdCBhbGlhc2VzID0gZGF0YS5hbGlhc2VzIHx8IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBsZXQgY3VycmVudFByb3BzID0ge307XG4gIGZ1bmN0aW9uIHBhcnNlKG5hbWUyKSB7XG4gICAgY3VycmVudFByb3BzID0gbWVyZ2VJY29uRGF0YShcbiAgICAgIGljb25zW25hbWUyXSB8fCBhbGlhc2VzW25hbWUyXSxcbiAgICAgIGN1cnJlbnRQcm9wc1xuICAgICk7XG4gIH1cbiAgcGFyc2UobmFtZSk7XG4gIHRyZWUuZm9yRWFjaChwYXJzZSk7XG4gIHJldHVybiBtZXJnZUljb25EYXRhKGRhdGEsIGN1cnJlbnRQcm9wcyk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSWNvblNldChkYXRhLCBjYWxsYmFjaykge1xuICBjb25zdCBuYW1lcyA9IFtdO1xuICBpZiAodHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIgfHwgdHlwZW9mIGRhdGEuaWNvbnMgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gbmFtZXM7XG4gIH1cbiAgaWYgKGRhdGEubm90X2ZvdW5kIGluc3RhbmNlb2YgQXJyYXkpIHtcbiAgICBkYXRhLm5vdF9mb3VuZC5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICBjYWxsYmFjayhuYW1lLCBudWxsKTtcbiAgICAgIG5hbWVzLnB1c2gobmFtZSk7XG4gICAgfSk7XG4gIH1cbiAgY29uc3QgdHJlZSA9IGdldEljb25zVHJlZShkYXRhKTtcbiAgZm9yIChjb25zdCBuYW1lIGluIHRyZWUpIHtcbiAgICBjb25zdCBpdGVtID0gdHJlZVtuYW1lXTtcbiAgICBpZiAoaXRlbSkge1xuICAgICAgY2FsbGJhY2sobmFtZSwgaW50ZXJuYWxHZXRJY29uRGF0YShkYXRhLCBuYW1lLCBpdGVtKSk7XG4gICAgICBuYW1lcy5wdXNoKG5hbWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmFtZXM7XG59XG5cbmNvbnN0IG9wdGlvbmFsUHJvcGVydHlEZWZhdWx0cyA9IHtcbiAgcHJvdmlkZXI6IFwiXCIsXG4gIGFsaWFzZXM6IHt9LFxuICBub3RfZm91bmQ6IHt9LFxuICAuLi5kZWZhdWx0SWNvbkRpbWVuc2lvbnNcbn07XG5mdW5jdGlvbiBjaGVja09wdGlvbmFsUHJvcHMoaXRlbSwgZGVmYXVsdHMpIHtcbiAgZm9yIChjb25zdCBwcm9wIGluIGRlZmF1bHRzKSB7XG4gICAgaWYgKHByb3AgaW4gaXRlbSAmJiB0eXBlb2YgaXRlbVtwcm9wXSAhPT0gdHlwZW9mIGRlZmF1bHRzW3Byb3BdKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcXVpY2tseVZhbGlkYXRlSWNvblNldChvYmopIHtcbiAgaWYgKHR5cGVvZiBvYmogIT09IFwib2JqZWN0XCIgfHwgb2JqID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgY29uc3QgZGF0YSA9IG9iajtcbiAgaWYgKHR5cGVvZiBkYXRhLnByZWZpeCAhPT0gXCJzdHJpbmdcIiB8fCAhb2JqLmljb25zIHx8IHR5cGVvZiBvYmouaWNvbnMgIT09IFwib2JqZWN0XCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAoIWNoZWNrT3B0aW9uYWxQcm9wcyhvYmosIG9wdGlvbmFsUHJvcGVydHlEZWZhdWx0cykpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBpY29ucyA9IGRhdGEuaWNvbnM7XG4gIGZvciAoY29uc3QgbmFtZSBpbiBpY29ucykge1xuICAgIGNvbnN0IGljb24gPSBpY29uc1tuYW1lXTtcbiAgICBpZiAoIW5hbWUubWF0Y2gobWF0Y2hJY29uTmFtZSkgfHwgdHlwZW9mIGljb24uYm9keSAhPT0gXCJzdHJpbmdcIiB8fCAhY2hlY2tPcHRpb25hbFByb3BzKFxuICAgICAgaWNvbixcbiAgICAgIGRlZmF1bHRFeHRlbmRlZEljb25Qcm9wc1xuICAgICkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBjb25zdCBhbGlhc2VzID0gZGF0YS5hbGlhc2VzIHx8IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gYWxpYXNlcykge1xuICAgIGNvbnN0IGljb24gPSBhbGlhc2VzW25hbWVdO1xuICAgIGNvbnN0IHBhcmVudCA9IGljb24ucGFyZW50O1xuICAgIGlmICghbmFtZS5tYXRjaChtYXRjaEljb25OYW1lKSB8fCB0eXBlb2YgcGFyZW50ICE9PSBcInN0cmluZ1wiIHx8ICFpY29uc1twYXJlbnRdICYmICFhbGlhc2VzW3BhcmVudF0gfHwgIWNoZWNrT3B0aW9uYWxQcm9wcyhcbiAgICAgIGljb24sXG4gICAgICBkZWZhdWx0RXh0ZW5kZWRJY29uUHJvcHNcbiAgICApKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRhdGE7XG59XG5cbmNvbnN0IGRhdGFTdG9yYWdlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBuZXdTdG9yYWdlKHByb3ZpZGVyLCBwcmVmaXgpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm92aWRlcixcbiAgICBwcmVmaXgsXG4gICAgaWNvbnM6IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpLFxuICAgIG1pc3Npbmc6IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KClcbiAgfTtcbn1cbmZ1bmN0aW9uIGdldFN0b3JhZ2UocHJvdmlkZXIsIHByZWZpeCkge1xuICBjb25zdCBwcm92aWRlclN0b3JhZ2UgPSBkYXRhU3RvcmFnZVtwcm92aWRlcl0gfHwgKGRhdGFTdG9yYWdlW3Byb3ZpZGVyXSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgcmV0dXJuIHByb3ZpZGVyU3RvcmFnZVtwcmVmaXhdIHx8IChwcm92aWRlclN0b3JhZ2VbcHJlZml4XSA9IG5ld1N0b3JhZ2UocHJvdmlkZXIsIHByZWZpeCkpO1xufVxuZnVuY3Rpb24gYWRkSWNvblNldChzdG9yYWdlLCBkYXRhKSB7XG4gIGlmICghcXVpY2tseVZhbGlkYXRlSWNvblNldChkYXRhKSkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICByZXR1cm4gcGFyc2VJY29uU2V0KGRhdGEsIChuYW1lLCBpY29uKSA9PiB7XG4gICAgaWYgKGljb24pIHtcbiAgICAgIHN0b3JhZ2UuaWNvbnNbbmFtZV0gPSBpY29uO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdG9yYWdlLm1pc3NpbmcuYWRkKG5hbWUpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBhZGRJY29uVG9TdG9yYWdlKHN0b3JhZ2UsIG5hbWUsIGljb24pIHtcbiAgdHJ5IHtcbiAgICBpZiAodHlwZW9mIGljb24uYm9keSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgc3RvcmFnZS5pY29uc1tuYW1lXSA9IHsgLi4uaWNvbiB9O1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBsaXN0SWNvbnMkMShwcm92aWRlciwgcHJlZml4KSB7XG4gIGxldCBhbGxJY29ucyA9IFtdO1xuICBjb25zdCBwcm92aWRlcnMgPSB0eXBlb2YgcHJvdmlkZXIgPT09IFwic3RyaW5nXCIgPyBbcHJvdmlkZXJdIDogT2JqZWN0LmtleXMoZGF0YVN0b3JhZ2UpO1xuICBwcm92aWRlcnMuZm9yRWFjaCgocHJvdmlkZXIyKSA9PiB7XG4gICAgY29uc3QgcHJlZml4ZXMgPSB0eXBlb2YgcHJvdmlkZXIyID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBwcmVmaXggPT09IFwic3RyaW5nXCIgPyBbcHJlZml4XSA6IE9iamVjdC5rZXlzKGRhdGFTdG9yYWdlW3Byb3ZpZGVyMl0gfHwge30pO1xuICAgIHByZWZpeGVzLmZvckVhY2goKHByZWZpeDIpID0+IHtcbiAgICAgIGNvbnN0IHN0b3JhZ2UgPSBnZXRTdG9yYWdlKHByb3ZpZGVyMiwgcHJlZml4Mik7XG4gICAgICBhbGxJY29ucyA9IGFsbEljb25zLmNvbmNhdChcbiAgICAgICAgT2JqZWN0LmtleXMoc3RvcmFnZS5pY29ucykubWFwKFxuICAgICAgICAgIChuYW1lKSA9PiAocHJvdmlkZXIyICE9PSBcIlwiID8gXCJAXCIgKyBwcm92aWRlcjIgKyBcIjpcIiA6IFwiXCIpICsgcHJlZml4MiArIFwiOlwiICsgbmFtZVxuICAgICAgICApXG4gICAgICApO1xuICAgIH0pO1xuICB9KTtcbiAgcmV0dXJuIGFsbEljb25zO1xufVxuXG5sZXQgc2ltcGxlTmFtZXMgPSBmYWxzZTtcbmZ1bmN0aW9uIGFsbG93U2ltcGxlTmFtZXMoYWxsb3cpIHtcbiAgaWYgKHR5cGVvZiBhbGxvdyA9PT0gXCJib29sZWFuXCIpIHtcbiAgICBzaW1wbGVOYW1lcyA9IGFsbG93O1xuICB9XG4gIHJldHVybiBzaW1wbGVOYW1lcztcbn1cbmZ1bmN0aW9uIGdldEljb25EYXRhKG5hbWUpIHtcbiAgY29uc3QgaWNvbiA9IHR5cGVvZiBuYW1lID09PSBcInN0cmluZ1wiID8gc3RyaW5nVG9JY29uKG5hbWUsIHRydWUsIHNpbXBsZU5hbWVzKSA6IG5hbWU7XG4gIGlmIChpY29uKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IGdldFN0b3JhZ2UoaWNvbi5wcm92aWRlciwgaWNvbi5wcmVmaXgpO1xuICAgIGNvbnN0IGljb25OYW1lID0gaWNvbi5uYW1lO1xuICAgIHJldHVybiBzdG9yYWdlLmljb25zW2ljb25OYW1lXSB8fCAoc3RvcmFnZS5taXNzaW5nLmhhcyhpY29uTmFtZSkgPyBudWxsIDogdm9pZCAwKTtcbiAgfVxufVxuZnVuY3Rpb24gYWRkSWNvbiQxKG5hbWUsIGRhdGEpIHtcbiAgY29uc3QgaWNvbiA9IHN0cmluZ1RvSWNvbihuYW1lLCB0cnVlLCBzaW1wbGVOYW1lcyk7XG4gIGlmICghaWNvbikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBzdG9yYWdlID0gZ2V0U3RvcmFnZShpY29uLnByb3ZpZGVyLCBpY29uLnByZWZpeCk7XG4gIHJldHVybiBhZGRJY29uVG9TdG9yYWdlKHN0b3JhZ2UsIGljb24ubmFtZSwgZGF0YSk7XG59XG5mdW5jdGlvbiBhZGRDb2xsZWN0aW9uJDEoZGF0YSwgcHJvdmlkZXIpIHtcbiAgaWYgKHR5cGVvZiBkYXRhICE9PSBcIm9iamVjdFwiKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh0eXBlb2YgcHJvdmlkZXIgIT09IFwic3RyaW5nXCIpIHtcbiAgICBwcm92aWRlciA9IGRhdGEucHJvdmlkZXIgfHwgXCJcIjtcbiAgfVxuICBpZiAoc2ltcGxlTmFtZXMgJiYgIXByb3ZpZGVyICYmICFkYXRhLnByZWZpeCkge1xuICAgIGxldCBhZGRlZCA9IGZhbHNlO1xuICAgIGlmIChxdWlja2x5VmFsaWRhdGVJY29uU2V0KGRhdGEpKSB7XG4gICAgICBkYXRhLnByZWZpeCA9IFwiXCI7XG4gICAgICBwYXJzZUljb25TZXQoZGF0YSwgKG5hbWUsIGljb24pID0+IHtcbiAgICAgICAgaWYgKGljb24gJiYgYWRkSWNvbiQxKG5hbWUsIGljb24pKSB7XG4gICAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFkZGVkO1xuICB9XG4gIGNvbnN0IHByZWZpeCA9IGRhdGEucHJlZml4O1xuICBpZiAoIXZhbGlkYXRlSWNvbk5hbWUoe1xuICAgIHByb3ZpZGVyLFxuICAgIHByZWZpeCxcbiAgICBuYW1lOiBcImFcIlxuICB9KSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25zdCBzdG9yYWdlID0gZ2V0U3RvcmFnZShwcm92aWRlciwgcHJlZml4KTtcbiAgcmV0dXJuICEhYWRkSWNvblNldChzdG9yYWdlLCBkYXRhKTtcbn1cbmZ1bmN0aW9uIGljb25FeGlzdHMkMShuYW1lKSB7XG4gIHJldHVybiAhIWdldEljb25EYXRhKG5hbWUpO1xufVxuZnVuY3Rpb24gZ2V0SWNvbiQxKG5hbWUpIHtcbiAgY29uc3QgcmVzdWx0ID0gZ2V0SWNvbkRhdGEobmFtZSk7XG4gIHJldHVybiByZXN1bHQgPyB7XG4gICAgLi4uZGVmYXVsdEljb25Qcm9wcyxcbiAgICAuLi5yZXN1bHRcbiAgfSA6IG51bGw7XG59XG5cbmZ1bmN0aW9uIHNvcnRJY29ucyhpY29ucykge1xuICBjb25zdCByZXN1bHQgPSB7XG4gICAgbG9hZGVkOiBbXSxcbiAgICBtaXNzaW5nOiBbXSxcbiAgICBwZW5kaW5nOiBbXVxuICB9O1xuICBjb25zdCBzdG9yYWdlID0gLyogQF9fUFVSRV9fICovIE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGljb25zLnNvcnQoKGEsIGIpID0+IHtcbiAgICBpZiAoYS5wcm92aWRlciAhPT0gYi5wcm92aWRlcikge1xuICAgICAgcmV0dXJuIGEucHJvdmlkZXIubG9jYWxlQ29tcGFyZShiLnByb3ZpZGVyKTtcbiAgICB9XG4gICAgaWYgKGEucHJlZml4ICE9PSBiLnByZWZpeCkge1xuICAgICAgcmV0dXJuIGEucHJlZml4LmxvY2FsZUNvbXBhcmUoYi5wcmVmaXgpO1xuICAgIH1cbiAgICByZXR1cm4gYS5uYW1lLmxvY2FsZUNvbXBhcmUoYi5uYW1lKTtcbiAgfSk7XG4gIGxldCBsYXN0SWNvbiA9IHtcbiAgICBwcm92aWRlcjogXCJcIixcbiAgICBwcmVmaXg6IFwiXCIsXG4gICAgbmFtZTogXCJcIlxuICB9O1xuICBpY29ucy5mb3JFYWNoKChpY29uKSA9PiB7XG4gICAgaWYgKGxhc3RJY29uLm5hbWUgPT09IGljb24ubmFtZSAmJiBsYXN0SWNvbi5wcmVmaXggPT09IGljb24ucHJlZml4ICYmIGxhc3RJY29uLnByb3ZpZGVyID09PSBpY29uLnByb3ZpZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxhc3RJY29uID0gaWNvbjtcbiAgICBjb25zdCBwcm92aWRlciA9IGljb24ucHJvdmlkZXI7XG4gICAgY29uc3QgcHJlZml4ID0gaWNvbi5wcmVmaXg7XG4gICAgY29uc3QgbmFtZSA9IGljb24ubmFtZTtcbiAgICBjb25zdCBwcm92aWRlclN0b3JhZ2UgPSBzdG9yYWdlW3Byb3ZpZGVyXSB8fCAoc3RvcmFnZVtwcm92aWRlcl0gPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKSk7XG4gICAgY29uc3QgbG9jYWxTdG9yYWdlID0gcHJvdmlkZXJTdG9yYWdlW3ByZWZpeF0gfHwgKHByb3ZpZGVyU3RvcmFnZVtwcmVmaXhdID0gZ2V0U3RvcmFnZShwcm92aWRlciwgcHJlZml4KSk7XG4gICAgbGV0IGxpc3Q7XG4gICAgaWYgKG5hbWUgaW4gbG9jYWxTdG9yYWdlLmljb25zKSB7XG4gICAgICBsaXN0ID0gcmVzdWx0LmxvYWRlZDtcbiAgICB9IGVsc2UgaWYgKHByZWZpeCA9PT0gXCJcIiB8fCBsb2NhbFN0b3JhZ2UubWlzc2luZy5oYXMobmFtZSkpIHtcbiAgICAgIGxpc3QgPSByZXN1bHQubWlzc2luZztcbiAgICB9IGVsc2Uge1xuICAgICAgbGlzdCA9IHJlc3VsdC5wZW5kaW5nO1xuICAgIH1cbiAgICBjb25zdCBpdGVtID0ge1xuICAgICAgcHJvdmlkZXIsXG4gICAgICBwcmVmaXgsXG4gICAgICBuYW1lXG4gICAgfTtcbiAgICBsaXN0LnB1c2goaXRlbSk7XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG5mdW5jdGlvbiByZW1vdmVDYWxsYmFjayhzdG9yYWdlcywgaWQpIHtcbiAgc3RvcmFnZXMuZm9yRWFjaCgoc3RvcmFnZSkgPT4ge1xuICAgIGNvbnN0IGl0ZW1zID0gc3RvcmFnZS5sb2FkZXJDYWxsYmFja3M7XG4gICAgaWYgKGl0ZW1zKSB7XG4gICAgICBzdG9yYWdlLmxvYWRlckNhbGxiYWNrcyA9IGl0ZW1zLmZpbHRlcigocm93KSA9PiByb3cuaWQgIT09IGlkKTtcbiAgICB9XG4gIH0pO1xufVxuZnVuY3Rpb24gdXBkYXRlQ2FsbGJhY2tzKHN0b3JhZ2UpIHtcbiAgaWYgKCFzdG9yYWdlLnBlbmRpbmdDYWxsYmFja3NGbGFnKSB7XG4gICAgc3RvcmFnZS5wZW5kaW5nQ2FsbGJhY2tzRmxhZyA9IHRydWU7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzdG9yYWdlLnBlbmRpbmdDYWxsYmFja3NGbGFnID0gZmFsc2U7XG4gICAgICBjb25zdCBpdGVtcyA9IHN0b3JhZ2UubG9hZGVyQ2FsbGJhY2tzID8gc3RvcmFnZS5sb2FkZXJDYWxsYmFja3Muc2xpY2UoMCkgOiBbXTtcbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBoYXNQZW5kaW5nID0gZmFsc2U7XG4gICAgICBjb25zdCBwcm92aWRlciA9IHN0b3JhZ2UucHJvdmlkZXI7XG4gICAgICBjb25zdCBwcmVmaXggPSBzdG9yYWdlLnByZWZpeDtcbiAgICAgIGl0ZW1zLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgaWNvbnMgPSBpdGVtLmljb25zO1xuICAgICAgICBjb25zdCBvbGRMZW5ndGggPSBpY29ucy5wZW5kaW5nLmxlbmd0aDtcbiAgICAgICAgaWNvbnMucGVuZGluZyA9IGljb25zLnBlbmRpbmcuZmlsdGVyKChpY29uKSA9PiB7XG4gICAgICAgICAgaWYgKGljb24ucHJlZml4ICE9PSBwcmVmaXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBuYW1lID0gaWNvbi5uYW1lO1xuICAgICAgICAgIGlmIChzdG9yYWdlLmljb25zW25hbWVdKSB7XG4gICAgICAgICAgICBpY29ucy5sb2FkZWQucHVzaCh7XG4gICAgICAgICAgICAgIHByb3ZpZGVyLFxuICAgICAgICAgICAgICBwcmVmaXgsXG4gICAgICAgICAgICAgIG5hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RvcmFnZS5taXNzaW5nLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgaWNvbnMubWlzc2luZy5wdXNoKHtcbiAgICAgICAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgICAgICAgIHByZWZpeCxcbiAgICAgICAgICAgICAgbmFtZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGhhc1BlbmRpbmcgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChpY29ucy5wZW5kaW5nLmxlbmd0aCAhPT0gb2xkTGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKCFoYXNQZW5kaW5nKSB7XG4gICAgICAgICAgICByZW1vdmVDYWxsYmFjayhbc3RvcmFnZV0sIGl0ZW0uaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpdGVtLmNhbGxiYWNrKFxuICAgICAgICAgICAgaWNvbnMubG9hZGVkLnNsaWNlKDApLFxuICAgICAgICAgICAgaWNvbnMubWlzc2luZy5zbGljZSgwKSxcbiAgICAgICAgICAgIGljb25zLnBlbmRpbmcuc2xpY2UoMCksXG4gICAgICAgICAgICBpdGVtLmFib3J0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbn1cbmxldCBpZENvdW50ZXIgPSAwO1xuZnVuY3Rpb24gc3RvcmVDYWxsYmFjayhjYWxsYmFjaywgaWNvbnMsIHBlbmRpbmdTb3VyY2VzKSB7XG4gIGNvbnN0IGlkID0gaWRDb3VudGVyKys7XG4gIGNvbnN0IGFib3J0ID0gcmVtb3ZlQ2FsbGJhY2suYmluZChudWxsLCBwZW5kaW5nU291cmNlcywgaWQpO1xuICBpZiAoIWljb25zLnBlbmRpbmcubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGFib3J0O1xuICB9XG4gIGNvbnN0IGl0ZW0gPSB7XG4gICAgaWQsXG4gICAgaWNvbnMsXG4gICAgY2FsbGJhY2ssXG4gICAgYWJvcnRcbiAgfTtcbiAgcGVuZGluZ1NvdXJjZXMuZm9yRWFjaCgoc3RvcmFnZSkgPT4ge1xuICAgIChzdG9yYWdlLmxvYWRlckNhbGxiYWNrcyB8fCAoc3RvcmFnZS5sb2FkZXJDYWxsYmFja3MgPSBbXSkpLnB1c2goaXRlbSk7XG4gIH0pO1xuICByZXR1cm4gYWJvcnQ7XG59XG5cbmNvbnN0IHN0b3JhZ2UgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIHNldEFQSU1vZHVsZShwcm92aWRlciwgaXRlbSkge1xuICBzdG9yYWdlW3Byb3ZpZGVyXSA9IGl0ZW07XG59XG5mdW5jdGlvbiBnZXRBUElNb2R1bGUocHJvdmlkZXIpIHtcbiAgcmV0dXJuIHN0b3JhZ2VbcHJvdmlkZXJdIHx8IHN0b3JhZ2VbXCJcIl07XG59XG5cbmZ1bmN0aW9uIGxpc3RUb0ljb25zKGxpc3QsIHZhbGlkYXRlID0gdHJ1ZSwgc2ltcGxlTmFtZXMgPSBmYWxzZSkge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgbGlzdC5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgY29uc3QgaWNvbiA9IHR5cGVvZiBpdGVtID09PSBcInN0cmluZ1wiID8gc3RyaW5nVG9JY29uKGl0ZW0sIHZhbGlkYXRlLCBzaW1wbGVOYW1lcykgOiBpdGVtO1xuICAgIGlmIChpY29uKSB7XG4gICAgICByZXN1bHQucHVzaChpY29uKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvY29uZmlnLnRzXG52YXIgZGVmYXVsdENvbmZpZyA9IHtcbiAgcmVzb3VyY2VzOiBbXSxcbiAgaW5kZXg6IDAsXG4gIHRpbWVvdXQ6IDJlMyxcbiAgcm90YXRlOiA3NTAsXG4gIHJhbmRvbTogZmFsc2UsXG4gIGRhdGFBZnRlclRpbWVvdXQ6IGZhbHNlXG59O1xuXG4vLyBzcmMvcXVlcnkudHNcbmZ1bmN0aW9uIHNlbmRRdWVyeShjb25maWcsIHBheWxvYWQsIHF1ZXJ5LCBkb25lKSB7XG4gIGNvbnN0IHJlc291cmNlc0NvdW50ID0gY29uZmlnLnJlc291cmNlcy5sZW5ndGg7XG4gIGNvbnN0IHN0YXJ0SW5kZXggPSBjb25maWcucmFuZG9tID8gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogcmVzb3VyY2VzQ291bnQpIDogY29uZmlnLmluZGV4O1xuICBsZXQgcmVzb3VyY2VzO1xuICBpZiAoY29uZmlnLnJhbmRvbSkge1xuICAgIGxldCBsaXN0ID0gY29uZmlnLnJlc291cmNlcy5zbGljZSgwKTtcbiAgICByZXNvdXJjZXMgPSBbXTtcbiAgICB3aGlsZSAobGlzdC5sZW5ndGggPiAxKSB7XG4gICAgICBjb25zdCBuZXh0SW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBsaXN0Lmxlbmd0aCk7XG4gICAgICByZXNvdXJjZXMucHVzaChsaXN0W25leHRJbmRleF0pO1xuICAgICAgbGlzdCA9IGxpc3Quc2xpY2UoMCwgbmV4dEluZGV4KS5jb25jYXQobGlzdC5zbGljZShuZXh0SW5kZXggKyAxKSk7XG4gICAgfVxuICAgIHJlc291cmNlcyA9IHJlc291cmNlcy5jb25jYXQobGlzdCk7XG4gIH0gZWxzZSB7XG4gICAgcmVzb3VyY2VzID0gY29uZmlnLnJlc291cmNlcy5zbGljZShzdGFydEluZGV4KS5jb25jYXQoY29uZmlnLnJlc291cmNlcy5zbGljZSgwLCBzdGFydEluZGV4KSk7XG4gIH1cbiAgY29uc3Qgc3RhcnRUaW1lID0gRGF0ZS5ub3coKTtcbiAgbGV0IHN0YXR1cyA9IFwicGVuZGluZ1wiO1xuICBsZXQgcXVlcmllc1NlbnQgPSAwO1xuICBsZXQgbGFzdEVycm9yO1xuICBsZXQgdGltZXIgPSBudWxsO1xuICBsZXQgcXVldWUgPSBbXTtcbiAgbGV0IGRvbmVDYWxsYmFja3MgPSBbXTtcbiAgaWYgKHR5cGVvZiBkb25lID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBkb25lQ2FsbGJhY2tzLnB1c2goZG9uZSk7XG4gIH1cbiAgZnVuY3Rpb24gcmVzZXRUaW1lcigpIHtcbiAgICBpZiAodGltZXIpIHtcbiAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICB0aW1lciA9IG51bGw7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFib3J0KCkge1xuICAgIGlmIChzdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICBzdGF0dXMgPSBcImFib3J0ZWRcIjtcbiAgICB9XG4gICAgcmVzZXRUaW1lcigpO1xuICAgIHF1ZXVlLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIGlmIChpdGVtLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgaXRlbS5zdGF0dXMgPSBcImFib3J0ZWRcIjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBxdWV1ZSA9IFtdO1xuICB9XG4gIGZ1bmN0aW9uIHN1YnNjcmliZShjYWxsYmFjaywgb3ZlcndyaXRlKSB7XG4gICAgaWYgKG92ZXJ3cml0ZSkge1xuICAgICAgZG9uZUNhbGxiYWNrcyA9IFtdO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGRvbmVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGdldFF1ZXJ5U3RhdHVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICBzdGFydFRpbWUsXG4gICAgICBwYXlsb2FkLFxuICAgICAgc3RhdHVzLFxuICAgICAgcXVlcmllc1NlbnQsXG4gICAgICBxdWVyaWVzUGVuZGluZzogcXVldWUubGVuZ3RoLFxuICAgICAgc3Vic2NyaWJlLFxuICAgICAgYWJvcnRcbiAgICB9O1xuICB9XG4gIGZ1bmN0aW9uIGZhaWxRdWVyeSgpIHtcbiAgICBzdGF0dXMgPSBcImZhaWxlZFwiO1xuICAgIGRvbmVDYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spID0+IHtcbiAgICAgIGNhbGxiYWNrKHZvaWQgMCwgbGFzdEVycm9yKTtcbiAgICB9KTtcbiAgfVxuICBmdW5jdGlvbiBjbGVhclF1ZXVlKCkge1xuICAgIHF1ZXVlLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIGlmIChpdGVtLnN0YXR1cyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgaXRlbS5zdGF0dXMgPSBcImFib3J0ZWRcIjtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBxdWV1ZSA9IFtdO1xuICB9XG4gIGZ1bmN0aW9uIG1vZHVsZVJlc3BvbnNlKGl0ZW0sIHJlc3BvbnNlLCBkYXRhKSB7XG4gICAgY29uc3QgaXNFcnJvciA9IHJlc3BvbnNlICE9PSBcInN1Y2Nlc3NcIjtcbiAgICBxdWV1ZSA9IHF1ZXVlLmZpbHRlcigocXVldWVkKSA9PiBxdWV1ZWQgIT09IGl0ZW0pO1xuICAgIHN3aXRjaCAoc3RhdHVzKSB7XG4gICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJmYWlsZWRcIjpcbiAgICAgICAgaWYgKGlzRXJyb3IgfHwgIWNvbmZpZy5kYXRhQWZ0ZXJUaW1lb3V0KSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAocmVzcG9uc2UgPT09IFwiYWJvcnRcIikge1xuICAgICAgbGFzdEVycm9yID0gZGF0YTtcbiAgICAgIGZhaWxRdWVyeSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaXNFcnJvcikge1xuICAgICAgbGFzdEVycm9yID0gZGF0YTtcbiAgICAgIGlmICghcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGlmICghcmVzb3VyY2VzLmxlbmd0aCkge1xuICAgICAgICAgIGZhaWxRdWVyeSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGV4ZWNOZXh0KCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmVzZXRUaW1lcigpO1xuICAgIGNsZWFyUXVldWUoKTtcbiAgICBpZiAoIWNvbmZpZy5yYW5kb20pIHtcbiAgICAgIGNvbnN0IGluZGV4ID0gY29uZmlnLnJlc291cmNlcy5pbmRleE9mKGl0ZW0ucmVzb3VyY2UpO1xuICAgICAgaWYgKGluZGV4ICE9PSAtMSAmJiBpbmRleCAhPT0gY29uZmlnLmluZGV4KSB7XG4gICAgICAgIGNvbmZpZy5pbmRleCA9IGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICBzdGF0dXMgPSBcImNvbXBsZXRlZFwiO1xuICAgIGRvbmVDYWxsYmFja3MuZm9yRWFjaCgoY2FsbGJhY2spID0+IHtcbiAgICAgIGNhbGxiYWNrKGRhdGEpO1xuICAgIH0pO1xuICB9XG4gIGZ1bmN0aW9uIGV4ZWNOZXh0KCkge1xuICAgIGlmIChzdGF0dXMgIT09IFwicGVuZGluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJlc2V0VGltZXIoKTtcbiAgICBjb25zdCByZXNvdXJjZSA9IHJlc291cmNlcy5zaGlmdCgpO1xuICAgIGlmIChyZXNvdXJjZSA9PT0gdm9pZCAwKSB7XG4gICAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgcmVzZXRUaW1lcigpO1xuICAgICAgICAgIGlmIChzdGF0dXMgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICBjbGVhclF1ZXVlKCk7XG4gICAgICAgICAgICBmYWlsUXVlcnkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0sIGNvbmZpZy50aW1lb3V0KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZmFpbFF1ZXJ5KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICBzdGF0dXM6IFwicGVuZGluZ1wiLFxuICAgICAgcmVzb3VyY2UsXG4gICAgICBjYWxsYmFjazogKHN0YXR1czIsIGRhdGEpID0+IHtcbiAgICAgICAgbW9kdWxlUmVzcG9uc2UoaXRlbSwgc3RhdHVzMiwgZGF0YSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBxdWV1ZS5wdXNoKGl0ZW0pO1xuICAgIHF1ZXJpZXNTZW50Kys7XG4gICAgdGltZXIgPSBzZXRUaW1lb3V0KGV4ZWNOZXh0LCBjb25maWcucm90YXRlKTtcbiAgICBxdWVyeShyZXNvdXJjZSwgcGF5bG9hZCwgaXRlbS5jYWxsYmFjayk7XG4gIH1cbiAgc2V0VGltZW91dChleGVjTmV4dCk7XG4gIHJldHVybiBnZXRRdWVyeVN0YXR1cztcbn1cblxuLy8gc3JjL2luZGV4LnRzXG5mdW5jdGlvbiBpbml0UmVkdW5kYW5jeShjZmcpIHtcbiAgY29uc3QgY29uZmlnID0ge1xuICAgIC4uLmRlZmF1bHRDb25maWcsXG4gICAgLi4uY2ZnXG4gIH07XG4gIGxldCBxdWVyaWVzID0gW107XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgcXVlcmllcyA9IHF1ZXJpZXMuZmlsdGVyKChpdGVtKSA9PiBpdGVtKCkuc3RhdHVzID09PSBcInBlbmRpbmdcIik7XG4gIH1cbiAgZnVuY3Rpb24gcXVlcnkocGF5bG9hZCwgcXVlcnlDYWxsYmFjaywgZG9uZUNhbGxiYWNrKSB7XG4gICAgY29uc3QgcXVlcnkyID0gc2VuZFF1ZXJ5KFxuICAgICAgY29uZmlnLFxuICAgICAgcGF5bG9hZCxcbiAgICAgIHF1ZXJ5Q2FsbGJhY2ssXG4gICAgICAoZGF0YSwgZXJyb3IpID0+IHtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICBpZiAoZG9uZUNhbGxiYWNrKSB7XG4gICAgICAgICAgZG9uZUNhbGxiYWNrKGRhdGEsIGVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICk7XG4gICAgcXVlcmllcy5wdXNoKHF1ZXJ5Mik7XG4gICAgcmV0dXJuIHF1ZXJ5MjtcbiAgfVxuICBmdW5jdGlvbiBmaW5kKGNhbGxiYWNrKSB7XG4gICAgcmV0dXJuIHF1ZXJpZXMuZmluZCgodmFsdWUpID0+IHtcbiAgICAgIHJldHVybiBjYWxsYmFjayh2YWx1ZSk7XG4gICAgfSkgfHwgbnVsbDtcbiAgfVxuICBjb25zdCBpbnN0YW5jZSA9IHtcbiAgICBxdWVyeSxcbiAgICBmaW5kLFxuICAgIHNldEluZGV4OiAoaW5kZXgpID0+IHtcbiAgICAgIGNvbmZpZy5pbmRleCA9IGluZGV4O1xuICAgIH0sXG4gICAgZ2V0SW5kZXg6ICgpID0+IGNvbmZpZy5pbmRleCxcbiAgICBjbGVhbnVwXG4gIH07XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQVBJQ29uZmlnKHNvdXJjZSkge1xuICBsZXQgcmVzb3VyY2VzO1xuICBpZiAodHlwZW9mIHNvdXJjZS5yZXNvdXJjZXMgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXNvdXJjZXMgPSBbc291cmNlLnJlc291cmNlc107XG4gIH0gZWxzZSB7XG4gICAgcmVzb3VyY2VzID0gc291cmNlLnJlc291cmNlcztcbiAgICBpZiAoIShyZXNvdXJjZXMgaW5zdGFuY2VvZiBBcnJheSkgfHwgIXJlc291cmNlcy5sZW5ndGgpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBjb25zdCByZXN1bHQgPSB7XG4gICAgLy8gQVBJIGhvc3RzXG4gICAgcmVzb3VyY2VzLFxuICAgIC8vIFJvb3QgcGF0aFxuICAgIHBhdGg6IHNvdXJjZS5wYXRoIHx8IFwiL1wiLFxuICAgIC8vIFVSTCBsZW5ndGggbGltaXRcbiAgICBtYXhVUkw6IHNvdXJjZS5tYXhVUkwgfHwgNTAwLFxuICAgIC8vIFRpbWVvdXQgYmVmb3JlIG5leHQgaG9zdCBpcyB1c2VkLlxuICAgIHJvdGF0ZTogc291cmNlLnJvdGF0ZSB8fCA3NTAsXG4gICAgLy8gVGltZW91dCBiZWZvcmUgZmFpbGluZyBxdWVyeS5cbiAgICB0aW1lb3V0OiBzb3VyY2UudGltZW91dCB8fCA1ZTMsXG4gICAgLy8gUmFuZG9taXNlIGRlZmF1bHQgQVBJIGVuZCBwb2ludC5cbiAgICByYW5kb206IHNvdXJjZS5yYW5kb20gPT09IHRydWUsXG4gICAgLy8gU3RhcnQgaW5kZXhcbiAgICBpbmRleDogc291cmNlLmluZGV4IHx8IDAsXG4gICAgLy8gUmVjZWl2ZSBkYXRhIGFmdGVyIHRpbWUgb3V0ICh1c2VkIGlmIHRpbWUgb3V0IGtpY2tzIGluIGZpcnN0LCB0aGVuIEFQSSBtb2R1bGUgc2VuZHMgZGF0YSBhbnl3YXkpLlxuICAgIGRhdGFBZnRlclRpbWVvdXQ6IHNvdXJjZS5kYXRhQWZ0ZXJUaW1lb3V0ICE9PSBmYWxzZVxuICB9O1xuICByZXR1cm4gcmVzdWx0O1xufVxuY29uc3QgY29uZmlnU3RvcmFnZSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpO1xuY29uc3QgZmFsbEJhY2tBUElTb3VyY2VzID0gW1xuICBcImh0dHBzOi8vYXBpLnNpbXBsZXN2Zy5jb21cIixcbiAgXCJodHRwczovL2FwaS51bmlzdmcuY29tXCJcbl07XG5jb25zdCBmYWxsQmFja0FQSSA9IFtdO1xud2hpbGUgKGZhbGxCYWNrQVBJU291cmNlcy5sZW5ndGggPiAwKSB7XG4gIGlmIChmYWxsQmFja0FQSVNvdXJjZXMubGVuZ3RoID09PSAxKSB7XG4gICAgZmFsbEJhY2tBUEkucHVzaChmYWxsQmFja0FQSVNvdXJjZXMuc2hpZnQoKSk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKE1hdGgucmFuZG9tKCkgPiAwLjUpIHtcbiAgICAgIGZhbGxCYWNrQVBJLnB1c2goZmFsbEJhY2tBUElTb3VyY2VzLnNoaWZ0KCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBmYWxsQmFja0FQSS5wdXNoKGZhbGxCYWNrQVBJU291cmNlcy5wb3AoKSk7XG4gICAgfVxuICB9XG59XG5jb25maWdTdG9yYWdlW1wiXCJdID0gY3JlYXRlQVBJQ29uZmlnKHtcbiAgcmVzb3VyY2VzOiBbXCJodHRwczovL2FwaS5pY29uaWZ5LmRlc2lnblwiXS5jb25jYXQoZmFsbEJhY2tBUEkpXG59KTtcbmZ1bmN0aW9uIGFkZEFQSVByb3ZpZGVyJDEocHJvdmlkZXIsIGN1c3RvbUNvbmZpZykge1xuICBjb25zdCBjb25maWcgPSBjcmVhdGVBUElDb25maWcoY3VzdG9tQ29uZmlnKTtcbiAgaWYgKGNvbmZpZyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBjb25maWdTdG9yYWdlW3Byb3ZpZGVyXSA9IGNvbmZpZztcbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBnZXRBUElDb25maWcocHJvdmlkZXIpIHtcbiAgcmV0dXJuIGNvbmZpZ1N0b3JhZ2VbcHJvdmlkZXJdO1xufVxuZnVuY3Rpb24gbGlzdEFQSVByb3ZpZGVycygpIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKGNvbmZpZ1N0b3JhZ2UpO1xufVxuXG5mdW5jdGlvbiBlbXB0eUNhbGxiYWNrJDEoKSB7XG59XG5jb25zdCByZWR1bmRhbmN5Q2FjaGUgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbmZ1bmN0aW9uIGdldFJlZHVuZGFuY3lDYWNoZShwcm92aWRlcikge1xuICBpZiAoIXJlZHVuZGFuY3lDYWNoZVtwcm92aWRlcl0pIHtcbiAgICBjb25zdCBjb25maWcgPSBnZXRBUElDb25maWcocHJvdmlkZXIpO1xuICAgIGlmICghY29uZmlnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHJlZHVuZGFuY3kgPSBpbml0UmVkdW5kYW5jeShjb25maWcpO1xuICAgIGNvbnN0IGNhY2hlZFJldW5kYW5jeSA9IHtcbiAgICAgIGNvbmZpZyxcbiAgICAgIHJlZHVuZGFuY3lcbiAgICB9O1xuICAgIHJlZHVuZGFuY3lDYWNoZVtwcm92aWRlcl0gPSBjYWNoZWRSZXVuZGFuY3k7XG4gIH1cbiAgcmV0dXJuIHJlZHVuZGFuY3lDYWNoZVtwcm92aWRlcl07XG59XG5mdW5jdGlvbiBzZW5kQVBJUXVlcnkodGFyZ2V0LCBxdWVyeSwgY2FsbGJhY2spIHtcbiAgbGV0IHJlZHVuZGFuY3k7XG4gIGxldCBzZW5kO1xuICBpZiAodHlwZW9mIHRhcmdldCA9PT0gXCJzdHJpbmdcIikge1xuICAgIGNvbnN0IGFwaSA9IGdldEFQSU1vZHVsZSh0YXJnZXQpO1xuICAgIGlmICghYXBpKSB7XG4gICAgICBjYWxsYmFjayh2b2lkIDAsIDQyNCk7XG4gICAgICByZXR1cm4gZW1wdHlDYWxsYmFjayQxO1xuICAgIH1cbiAgICBzZW5kID0gYXBpLnNlbmQ7XG4gICAgY29uc3QgY2FjaGVkID0gZ2V0UmVkdW5kYW5jeUNhY2hlKHRhcmdldCk7XG4gICAgaWYgKGNhY2hlZCkge1xuICAgICAgcmVkdW5kYW5jeSA9IGNhY2hlZC5yZWR1bmRhbmN5O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjb25zdCBjb25maWcgPSBjcmVhdGVBUElDb25maWcodGFyZ2V0KTtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICByZWR1bmRhbmN5ID0gaW5pdFJlZHVuZGFuY3koY29uZmlnKTtcbiAgICAgIGNvbnN0IG1vZHVsZUtleSA9IHRhcmdldC5yZXNvdXJjZXMgPyB0YXJnZXQucmVzb3VyY2VzWzBdIDogXCJcIjtcbiAgICAgIGNvbnN0IGFwaSA9IGdldEFQSU1vZHVsZShtb2R1bGVLZXkpO1xuICAgICAgaWYgKGFwaSkge1xuICAgICAgICBzZW5kID0gYXBpLnNlbmQ7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghcmVkdW5kYW5jeSB8fCAhc2VuZCkge1xuICAgIGNhbGxiYWNrKHZvaWQgMCwgNDI0KTtcbiAgICByZXR1cm4gZW1wdHlDYWxsYmFjayQxO1xuICB9XG4gIHJldHVybiByZWR1bmRhbmN5LnF1ZXJ5KHF1ZXJ5LCBzZW5kLCBjYWxsYmFjaykoKS5hYm9ydDtcbn1cblxuY29uc3QgYnJvd3NlckNhY2hlVmVyc2lvbiA9IFwiaWNvbmlmeTJcIjtcbmNvbnN0IGJyb3dzZXJDYWNoZVByZWZpeCA9IFwiaWNvbmlmeVwiO1xuY29uc3QgYnJvd3NlckNhY2hlQ291bnRLZXkgPSBicm93c2VyQ2FjaGVQcmVmaXggKyBcIi1jb3VudFwiO1xuY29uc3QgYnJvd3NlckNhY2hlVmVyc2lvbktleSA9IGJyb3dzZXJDYWNoZVByZWZpeCArIFwiLXZlcnNpb25cIjtcbmNvbnN0IGJyb3dzZXJTdG9yYWdlSG91ciA9IDM2ZTU7XG5jb25zdCBicm93c2VyU3RvcmFnZUNhY2hlRXhwaXJhdGlvbiA9IDE2ODtcblxuZnVuY3Rpb24gZ2V0U3RvcmVkSXRlbShmdW5jLCBrZXkpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZnVuYy5nZXRJdGVtKGtleSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICB9XG59XG5mdW5jdGlvbiBzZXRTdG9yZWRJdGVtKGZ1bmMsIGtleSwgdmFsdWUpIHtcbiAgdHJ5IHtcbiAgICBmdW5jLnNldEl0ZW0oa2V5LCB2YWx1ZSk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGVycikge1xuICB9XG59XG5mdW5jdGlvbiByZW1vdmVTdG9yZWRJdGVtKGZ1bmMsIGtleSkge1xuICB0cnkge1xuICAgIGZ1bmMucmVtb3ZlSXRlbShrZXkpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRCcm93c2VyU3RvcmFnZUl0ZW1zQ291bnQoc3RvcmFnZSwgdmFsdWUpIHtcbiAgcmV0dXJuIHNldFN0b3JlZEl0ZW0oc3RvcmFnZSwgYnJvd3NlckNhY2hlQ291bnRLZXksIHZhbHVlLnRvU3RyaW5nKCkpO1xufVxuZnVuY3Rpb24gZ2V0QnJvd3NlclN0b3JhZ2VJdGVtc0NvdW50KHN0b3JhZ2UpIHtcbiAgcmV0dXJuIHBhcnNlSW50KGdldFN0b3JlZEl0ZW0oc3RvcmFnZSwgYnJvd3NlckNhY2hlQ291bnRLZXkpKSB8fCAwO1xufVxuXG5jb25zdCBicm93c2VyU3RvcmFnZUNvbmZpZyA9IHtcbiAgbG9jYWw6IHRydWUsXG4gIHNlc3Npb246IHRydWVcbn07XG5jb25zdCBicm93c2VyU3RvcmFnZUVtcHR5SXRlbXMgPSB7XG4gIGxvY2FsOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpLFxuICBzZXNzaW9uOiAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpXG59O1xubGV0IGJyb3dzZXJTdG9yYWdlU3RhdHVzID0gZmFsc2U7XG5mdW5jdGlvbiBzZXRCcm93c2VyU3RvcmFnZVN0YXR1cyhzdGF0dXMpIHtcbiAgYnJvd3NlclN0b3JhZ2VTdGF0dXMgPSBzdGF0dXM7XG59XG5cbmxldCBfd2luZG93ID0gdHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIiA/IHt9IDogd2luZG93O1xuZnVuY3Rpb24gZ2V0QnJvd3NlclN0b3JhZ2Uoa2V5KSB7XG4gIGNvbnN0IGF0dHIgPSBrZXkgKyBcIlN0b3JhZ2VcIjtcbiAgdHJ5IHtcbiAgICBpZiAoX3dpbmRvdyAmJiBfd2luZG93W2F0dHJdICYmIHR5cGVvZiBfd2luZG93W2F0dHJdLmxlbmd0aCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgcmV0dXJuIF93aW5kb3dbYXR0cl07XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgfVxuICBicm93c2VyU3RvcmFnZUNvbmZpZ1trZXldID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGl0ZXJhdGVCcm93c2VyU3RvcmFnZShrZXksIGNhbGxiYWNrKSB7XG4gIGNvbnN0IGZ1bmMgPSBnZXRCcm93c2VyU3RvcmFnZShrZXkpO1xuICBpZiAoIWZ1bmMpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgdmVyc2lvbiA9IGdldFN0b3JlZEl0ZW0oZnVuYywgYnJvd3NlckNhY2hlVmVyc2lvbktleSk7XG4gIGlmICh2ZXJzaW9uICE9PSBicm93c2VyQ2FjaGVWZXJzaW9uKSB7XG4gICAgaWYgKHZlcnNpb24pIHtcbiAgICAgIGNvbnN0IHRvdGFsMiA9IGdldEJyb3dzZXJTdG9yYWdlSXRlbXNDb3VudChmdW5jKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWwyOyBpKyspIHtcbiAgICAgICAgcmVtb3ZlU3RvcmVkSXRlbShmdW5jLCBicm93c2VyQ2FjaGVQcmVmaXggKyBpLnRvU3RyaW5nKCkpO1xuICAgICAgfVxuICAgIH1cbiAgICBzZXRTdG9yZWRJdGVtKGZ1bmMsIGJyb3dzZXJDYWNoZVZlcnNpb25LZXksIGJyb3dzZXJDYWNoZVZlcnNpb24pO1xuICAgIHNldEJyb3dzZXJTdG9yYWdlSXRlbXNDb3VudChmdW5jLCAwKTtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgbWluVGltZSA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIGJyb3dzZXJTdG9yYWdlSG91cikgLSBicm93c2VyU3RvcmFnZUNhY2hlRXhwaXJhdGlvbjtcbiAgY29uc3QgcGFyc2VJdGVtID0gKGluZGV4KSA9PiB7XG4gICAgY29uc3QgbmFtZSA9IGJyb3dzZXJDYWNoZVByZWZpeCArIGluZGV4LnRvU3RyaW5nKCk7XG4gICAgY29uc3QgaXRlbSA9IGdldFN0b3JlZEl0ZW0oZnVuYywgbmFtZSk7XG4gICAgaWYgKHR5cGVvZiBpdGVtICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShpdGVtKTtcbiAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgZGF0YS5jYWNoZWQgPT09IFwibnVtYmVyXCIgJiYgZGF0YS5jYWNoZWQgPiBtaW5UaW1lICYmIHR5cGVvZiBkYXRhLnByb3ZpZGVyID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBkYXRhLmRhdGEgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIGRhdGEuZGF0YS5wcmVmaXggPT09IFwic3RyaW5nXCIgJiYgLy8gVmFsaWQgaXRlbTogcnVuIGNhbGxiYWNrXG4gICAgICBjYWxsYmFjayhkYXRhLCBpbmRleCkpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgfVxuICAgIHJlbW92ZVN0b3JlZEl0ZW0oZnVuYywgbmFtZSk7XG4gIH07XG4gIGxldCB0b3RhbCA9IGdldEJyb3dzZXJTdG9yYWdlSXRlbXNDb3VudChmdW5jKTtcbiAgZm9yIChsZXQgaSA9IHRvdGFsIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAoIXBhcnNlSXRlbShpKSkge1xuICAgICAgaWYgKGkgPT09IHRvdGFsIC0gMSkge1xuICAgICAgICB0b3RhbC0tO1xuICAgICAgICBzZXRCcm93c2VyU3RvcmFnZUl0ZW1zQ291bnQoZnVuYywgdG90YWwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYnJvd3NlclN0b3JhZ2VFbXB0eUl0ZW1zW2tleV0uYWRkKGkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0QnJvd3NlclN0b3JhZ2UoKSB7XG4gIGlmIChicm93c2VyU3RvcmFnZVN0YXR1cykge1xuICAgIHJldHVybjtcbiAgfVxuICBzZXRCcm93c2VyU3RvcmFnZVN0YXR1cyh0cnVlKTtcbiAgZm9yIChjb25zdCBrZXkgaW4gYnJvd3NlclN0b3JhZ2VDb25maWcpIHtcbiAgICBpdGVyYXRlQnJvd3NlclN0b3JhZ2Uoa2V5LCAoaXRlbSkgPT4ge1xuICAgICAgY29uc3QgaWNvblNldCA9IGl0ZW0uZGF0YTtcbiAgICAgIGNvbnN0IHByb3ZpZGVyID0gaXRlbS5wcm92aWRlcjtcbiAgICAgIGNvbnN0IHByZWZpeCA9IGljb25TZXQucHJlZml4O1xuICAgICAgY29uc3Qgc3RvcmFnZSA9IGdldFN0b3JhZ2UoXG4gICAgICAgIHByb3ZpZGVyLFxuICAgICAgICBwcmVmaXhcbiAgICAgICk7XG4gICAgICBpZiAoIWFkZEljb25TZXQoc3RvcmFnZSwgaWNvblNldCkubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGxhc3RNb2RpZmllZCA9IGljb25TZXQubGFzdE1vZGlmaWVkIHx8IC0xO1xuICAgICAgc3RvcmFnZS5sYXN0TW9kaWZpZWRDYWNoZWQgPSBzdG9yYWdlLmxhc3RNb2RpZmllZENhY2hlZCA/IE1hdGgubWluKHN0b3JhZ2UubGFzdE1vZGlmaWVkQ2FjaGVkLCBsYXN0TW9kaWZpZWQpIDogbGFzdE1vZGlmaWVkO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGFzdE1vZGlmaWVkKHN0b3JhZ2UsIGxhc3RNb2RpZmllZCkge1xuICBjb25zdCBsYXN0VmFsdWUgPSBzdG9yYWdlLmxhc3RNb2RpZmllZENhY2hlZDtcbiAgaWYgKFxuICAgIC8vIE1hdGNoZXMgb3IgbmV3ZXJcbiAgICBsYXN0VmFsdWUgJiYgbGFzdFZhbHVlID49IGxhc3RNb2RpZmllZFxuICApIHtcbiAgICByZXR1cm4gbGFzdFZhbHVlID09PSBsYXN0TW9kaWZpZWQ7XG4gIH1cbiAgc3RvcmFnZS5sYXN0TW9kaWZpZWRDYWNoZWQgPSBsYXN0TW9kaWZpZWQ7XG4gIGlmIChsYXN0VmFsdWUpIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBicm93c2VyU3RvcmFnZUNvbmZpZykge1xuICAgICAgaXRlcmF0ZUJyb3dzZXJTdG9yYWdlKGtleSwgKGl0ZW0pID0+IHtcbiAgICAgICAgY29uc3QgaWNvblNldCA9IGl0ZW0uZGF0YTtcbiAgICAgICAgcmV0dXJuIGl0ZW0ucHJvdmlkZXIgIT09IHN0b3JhZ2UucHJvdmlkZXIgfHwgaWNvblNldC5wcmVmaXggIT09IHN0b3JhZ2UucHJlZml4IHx8IGljb25TZXQubGFzdE1vZGlmaWVkID09PSBsYXN0TW9kaWZpZWQ7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBzdG9yZUluQnJvd3NlclN0b3JhZ2Uoc3RvcmFnZSwgZGF0YSkge1xuICBpZiAoIWJyb3dzZXJTdG9yYWdlU3RhdHVzKSB7XG4gICAgaW5pdEJyb3dzZXJTdG9yYWdlKCk7XG4gIH1cbiAgZnVuY3Rpb24gc3RvcmUoa2V5KSB7XG4gICAgbGV0IGZ1bmM7XG4gICAgaWYgKCFicm93c2VyU3RvcmFnZUNvbmZpZ1trZXldIHx8ICEoZnVuYyA9IGdldEJyb3dzZXJTdG9yYWdlKGtleSkpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNldCA9IGJyb3dzZXJTdG9yYWdlRW1wdHlJdGVtc1trZXldO1xuICAgIGxldCBpbmRleDtcbiAgICBpZiAoc2V0LnNpemUpIHtcbiAgICAgIHNldC5kZWxldGUoaW5kZXggPSBBcnJheS5mcm9tKHNldCkuc2hpZnQoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGluZGV4ID0gZ2V0QnJvd3NlclN0b3JhZ2VJdGVtc0NvdW50KGZ1bmMpO1xuICAgICAgaWYgKCFzZXRCcm93c2VyU3RvcmFnZUl0ZW1zQ291bnQoZnVuYywgaW5kZXggKyAxKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGl0ZW0gPSB7XG4gICAgICBjYWNoZWQ6IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIGJyb3dzZXJTdG9yYWdlSG91ciksXG4gICAgICBwcm92aWRlcjogc3RvcmFnZS5wcm92aWRlcixcbiAgICAgIGRhdGFcbiAgICB9O1xuICAgIHJldHVybiBzZXRTdG9yZWRJdGVtKFxuICAgICAgZnVuYyxcbiAgICAgIGJyb3dzZXJDYWNoZVByZWZpeCArIGluZGV4LnRvU3RyaW5nKCksXG4gICAgICBKU09OLnN0cmluZ2lmeShpdGVtKVxuICAgICk7XG4gIH1cbiAgaWYgKGRhdGEubGFzdE1vZGlmaWVkICYmICF1cGRhdGVMYXN0TW9kaWZpZWQoc3RvcmFnZSwgZGF0YS5sYXN0TW9kaWZpZWQpKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmICghT2JqZWN0LmtleXMoZGF0YS5pY29ucykubGVuZ3RoKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGlmIChkYXRhLm5vdF9mb3VuZCkge1xuICAgIGRhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBkYXRhKTtcbiAgICBkZWxldGUgZGF0YS5ub3RfZm91bmQ7XG4gIH1cbiAgaWYgKCFzdG9yZShcImxvY2FsXCIpKSB7XG4gICAgc3RvcmUoXCJzZXNzaW9uXCIpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtcHR5Q2FsbGJhY2soKSB7XG59XG5mdW5jdGlvbiBsb2FkZWROZXdJY29ucyhzdG9yYWdlKSB7XG4gIGlmICghc3RvcmFnZS5pY29uc0xvYWRlckZsYWcpIHtcbiAgICBzdG9yYWdlLmljb25zTG9hZGVyRmxhZyA9IHRydWU7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBzdG9yYWdlLmljb25zTG9hZGVyRmxhZyA9IGZhbHNlO1xuICAgICAgdXBkYXRlQ2FsbGJhY2tzKHN0b3JhZ2UpO1xuICAgIH0pO1xuICB9XG59XG5mdW5jdGlvbiBsb2FkTmV3SWNvbnMoc3RvcmFnZSwgaWNvbnMpIHtcbiAgaWYgKCFzdG9yYWdlLmljb25zVG9Mb2FkKSB7XG4gICAgc3RvcmFnZS5pY29uc1RvTG9hZCA9IGljb25zO1xuICB9IGVsc2Uge1xuICAgIHN0b3JhZ2UuaWNvbnNUb0xvYWQgPSBzdG9yYWdlLmljb25zVG9Mb2FkLmNvbmNhdChpY29ucykuc29ydCgpO1xuICB9XG4gIGlmICghc3RvcmFnZS5pY29uc1F1ZXVlRmxhZykge1xuICAgIHN0b3JhZ2UuaWNvbnNRdWV1ZUZsYWcgPSB0cnVlO1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgc3RvcmFnZS5pY29uc1F1ZXVlRmxhZyA9IGZhbHNlO1xuICAgICAgY29uc3QgeyBwcm92aWRlciwgcHJlZml4IH0gPSBzdG9yYWdlO1xuICAgICAgY29uc3QgaWNvbnMyID0gc3RvcmFnZS5pY29uc1RvTG9hZDtcbiAgICAgIGRlbGV0ZSBzdG9yYWdlLmljb25zVG9Mb2FkO1xuICAgICAgbGV0IGFwaTtcbiAgICAgIGlmICghaWNvbnMyIHx8ICEoYXBpID0gZ2V0QVBJTW9kdWxlKHByb3ZpZGVyKSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFyYW1zID0gYXBpLnByZXBhcmUocHJvdmlkZXIsIHByZWZpeCwgaWNvbnMyKTtcbiAgICAgIHBhcmFtcy5mb3JFYWNoKChpdGVtKSA9PiB7XG4gICAgICAgIHNlbmRBUElRdWVyeShwcm92aWRlciwgaXRlbSwgKGRhdGEpID0+IHtcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGl0ZW0uaWNvbnMuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgICBzdG9yYWdlLm1pc3NpbmcuYWRkKG5hbWUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IGFkZEljb25TZXQoXG4gICAgICAgICAgICAgICAgc3RvcmFnZSxcbiAgICAgICAgICAgICAgICBkYXRhXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIGlmICghcGFyc2VkLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjb25zdCBwZW5kaW5nID0gc3RvcmFnZS5wZW5kaW5nSWNvbnM7XG4gICAgICAgICAgICAgIGlmIChwZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgcGFyc2VkLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICAgIHBlbmRpbmcuZGVsZXRlKG5hbWUpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0b3JlSW5Ccm93c2VyU3RvcmFnZShzdG9yYWdlLCBkYXRhKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGxvYWRlZE5ld0ljb25zKHN0b3JhZ2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG59XG5jb25zdCBsb2FkSWNvbnMkMSA9IChpY29ucywgY2FsbGJhY2spID0+IHtcbiAgY29uc3QgY2xlYW5lZEljb25zID0gbGlzdFRvSWNvbnMoaWNvbnMsIHRydWUsIGFsbG93U2ltcGxlTmFtZXMoKSk7XG4gIGNvbnN0IHNvcnRlZEljb25zID0gc29ydEljb25zKGNsZWFuZWRJY29ucyk7XG4gIGlmICghc29ydGVkSWNvbnMucGVuZGluZy5sZW5ndGgpIHtcbiAgICBsZXQgY2FsbENhbGxiYWNrID0gdHJ1ZTtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBpZiAoY2FsbENhbGxiYWNrKSB7XG4gICAgICAgICAgY2FsbGJhY2soXG4gICAgICAgICAgICBzb3J0ZWRJY29ucy5sb2FkZWQsXG4gICAgICAgICAgICBzb3J0ZWRJY29ucy5taXNzaW5nLFxuICAgICAgICAgICAgc29ydGVkSWNvbnMucGVuZGluZyxcbiAgICAgICAgICAgIGVtcHR5Q2FsbGJhY2tcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGNhbGxDYWxsYmFjayA9IGZhbHNlO1xuICAgIH07XG4gIH1cbiAgY29uc3QgbmV3SWNvbnMgPSAvKiBAX19QVVJFX18gKi8gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgY29uc3Qgc291cmNlcyA9IFtdO1xuICBsZXQgbGFzdFByb3ZpZGVyLCBsYXN0UHJlZml4O1xuICBzb3J0ZWRJY29ucy5wZW5kaW5nLmZvckVhY2goKGljb24pID0+IHtcbiAgICBjb25zdCB7IHByb3ZpZGVyLCBwcmVmaXggfSA9IGljb247XG4gICAgaWYgKHByZWZpeCA9PT0gbGFzdFByZWZpeCAmJiBwcm92aWRlciA9PT0gbGFzdFByb3ZpZGVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGxhc3RQcm92aWRlciA9IHByb3ZpZGVyO1xuICAgIGxhc3RQcmVmaXggPSBwcmVmaXg7XG4gICAgc291cmNlcy5wdXNoKGdldFN0b3JhZ2UocHJvdmlkZXIsIHByZWZpeCkpO1xuICAgIGNvbnN0IHByb3ZpZGVyTmV3SWNvbnMgPSBuZXdJY29uc1twcm92aWRlcl0gfHwgKG5ld0ljb25zW3Byb3ZpZGVyXSA9IC8qIEBfX1BVUkVfXyAqLyBPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICBpZiAoIXByb3ZpZGVyTmV3SWNvbnNbcHJlZml4XSkge1xuICAgICAgcHJvdmlkZXJOZXdJY29uc1twcmVmaXhdID0gW107XG4gICAgfVxuICB9KTtcbiAgc29ydGVkSWNvbnMucGVuZGluZy5mb3JFYWNoKChpY29uKSA9PiB7XG4gICAgY29uc3QgeyBwcm92aWRlciwgcHJlZml4LCBuYW1lIH0gPSBpY29uO1xuICAgIGNvbnN0IHN0b3JhZ2UgPSBnZXRTdG9yYWdlKHByb3ZpZGVyLCBwcmVmaXgpO1xuICAgIGNvbnN0IHBlbmRpbmdRdWV1ZSA9IHN0b3JhZ2UucGVuZGluZ0ljb25zIHx8IChzdG9yYWdlLnBlbmRpbmdJY29ucyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCkpO1xuICAgIGlmICghcGVuZGluZ1F1ZXVlLmhhcyhuYW1lKSkge1xuICAgICAgcGVuZGluZ1F1ZXVlLmFkZChuYW1lKTtcbiAgICAgIG5ld0ljb25zW3Byb3ZpZGVyXVtwcmVmaXhdLnB1c2gobmFtZSk7XG4gICAgfVxuICB9KTtcbiAgc291cmNlcy5mb3JFYWNoKChzdG9yYWdlKSA9PiB7XG4gICAgY29uc3QgeyBwcm92aWRlciwgcHJlZml4IH0gPSBzdG9yYWdlO1xuICAgIGlmIChuZXdJY29uc1twcm92aWRlcl1bcHJlZml4XS5sZW5ndGgpIHtcbiAgICAgIGxvYWROZXdJY29ucyhzdG9yYWdlLCBuZXdJY29uc1twcm92aWRlcl1bcHJlZml4XSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGNhbGxiYWNrID8gc3RvcmVDYWxsYmFjayhjYWxsYmFjaywgc29ydGVkSWNvbnMsIHNvdXJjZXMpIDogZW1wdHlDYWxsYmFjaztcbn07XG5jb25zdCBsb2FkSWNvbiQxID0gKGljb24pID0+IHtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChmdWxmaWxsLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBpY29uT2JqID0gdHlwZW9mIGljb24gPT09IFwic3RyaW5nXCIgPyBzdHJpbmdUb0ljb24oaWNvbiwgdHJ1ZSkgOiBpY29uO1xuICAgIGlmICghaWNvbk9iaikge1xuICAgICAgcmVqZWN0KGljb24pO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsb2FkSWNvbnMkMShbaWNvbk9iaiB8fCBpY29uXSwgKGxvYWRlZCkgPT4ge1xuICAgICAgaWYgKGxvYWRlZC5sZW5ndGggJiYgaWNvbk9iaikge1xuICAgICAgICBjb25zdCBkYXRhID0gZ2V0SWNvbkRhdGEoaWNvbk9iaik7XG4gICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgZnVsZmlsbCh7XG4gICAgICAgICAgICAuLi5kZWZhdWx0SWNvblByb3BzLFxuICAgICAgICAgICAgLi4uZGF0YVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVqZWN0KGljb24pO1xuICAgIH0pO1xuICB9KTtcbn07XG5cbi8qKlxuICogVGVzdCBpY29uIHN0cmluZ1xuICovXG5mdW5jdGlvbiB0ZXN0SWNvbk9iamVjdCh2YWx1ZSkge1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKHZhbHVlKSA6IHZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIG9iai5ib2R5ID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAuLi5vYmosXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy9cbiAgICB9XG59XG5cbi8qKlxuICogUGFyc2UgaWNvbiB2YWx1ZSwgbG9hZCBpZiBuZWVkZWRcbiAqL1xuZnVuY3Rpb24gcGFyc2VJY29uVmFsdWUodmFsdWUsIG9ubG9hZCkge1xuICAgIC8vIENoZWNrIGlmIGljb24gbmFtZSBpcyB2YWxpZFxuICAgIGNvbnN0IG5hbWUgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gc3RyaW5nVG9JY29uKHZhbHVlLCB0cnVlLCB0cnVlKSA6IG51bGw7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICAgIC8vIFRlc3QgZm9yIHNlcmlhbGlzZWQgb2JqZWN0XG4gICAgICAgIGNvbnN0IGRhdGEgPSB0ZXN0SWNvbk9iamVjdCh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgIH07XG4gICAgfVxuICAgIC8vIFZhbGlkIGljb24gbmFtZTogY2hlY2sgaWYgZGF0YSBpcyBhdmFpbGFibGVcbiAgICBjb25zdCBkYXRhID0gZ2V0SWNvbkRhdGEobmFtZSk7XG4gICAgLy8gSWNvbiBkYXRhIGV4aXN0cyBvciBpY29uIGhhcyBubyBwcmVmaXguIERvIG5vdCBsb2FkIGljb24gZnJvbSBBUEkgaWYgaWNvbiBoYXMgbm8gcHJlZml4XG4gICAgaWYgKGRhdGEgIT09IHZvaWQgMCB8fCAhbmFtZS5wcmVmaXgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGRhdGEsIC8vIGNvdWxkIGJlICdudWxsJyAtPiBpY29uIGlzIG1pc3NpbmdcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gTG9hZCBpY29uXG4gICAgY29uc3QgbG9hZGluZyA9IGxvYWRJY29ucyQxKFtuYW1lXSwgKCkgPT4gb25sb2FkKHZhbHVlLCBuYW1lLCBnZXRJY29uRGF0YShuYW1lKSkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBuYW1lLFxuICAgICAgICBsb2FkaW5nLFxuICAgIH07XG59XG5cbi8qKlxuICogQ2hlY2sgZm9yIGlubGluZVxuICovXG5mdW5jdGlvbiBnZXRJbmxpbmUobm9kZSkge1xuICAgIHJldHVybiBub2RlLmhhc0F0dHJpYnV0ZSgnaW5saW5lJyk7XG59XG5cbi8vIENoZWNrIGZvciBTYWZhcmlcbmxldCBpc0J1Z2dlZFNhZmFyaSA9IGZhbHNlO1xudHJ5IHtcbiAgICBpc0J1Z2dlZFNhZmFyaSA9IG5hdmlnYXRvci52ZW5kb3IuaW5kZXhPZignQXBwbGUnKSA9PT0gMDtcbn1cbmNhdGNoIChlcnIpIHtcbiAgICAvL1xufVxuLyoqXG4gKiBHZXQgcmVuZGVyIG1vZGVcbiAqL1xuZnVuY3Rpb24gZ2V0UmVuZGVyTW9kZShib2R5LCBtb2RlKSB7XG4gICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgIC8vIEZvcmNlIG1vZGVcbiAgICAgICAgY2FzZSAnc3ZnJzpcbiAgICAgICAgY2FzZSAnYmcnOlxuICAgICAgICBjYXNlICdtYXNrJzpcbiAgICAgICAgICAgIHJldHVybiBtb2RlO1xuICAgIH1cbiAgICAvLyBDaGVjayBmb3IgYW5pbWF0aW9uLCB1c2UgJ3N0eWxlJyBmb3IgYW5pbWF0ZWQgaWNvbnMsIHVubGVzcyBicm93c2VyIGlzIFNhZmFyaVxuICAgIC8vIChvbmx5IDxhPiwgd2hpY2ggc2hvdWxkIGJlIGlnbm9yZWQgb3IgYW5pbWF0aW9ucyBzdGFydCB3aXRoICc8YScpXG4gICAgaWYgKG1vZGUgIT09ICdzdHlsZScgJiZcbiAgICAgICAgKGlzQnVnZ2VkU2FmYXJpIHx8IGJvZHkuaW5kZXhPZignPGEnKSA9PT0gLTEpKSB7XG4gICAgICAgIC8vIFJlbmRlciA8c3ZnPlxuICAgICAgICByZXR1cm4gJ3N2Zyc7XG4gICAgfVxuICAgIC8vIFVzZSBiYWNrZ3JvdW5kIG9yIG1hc2tcbiAgICByZXR1cm4gYm9keS5pbmRleE9mKCdjdXJyZW50Q29sb3InKSA9PT0gLTEgPyAnYmcnIDogJ21hc2snO1xufVxuXG5jb25zdCB1bml0c1NwbGl0ID0gLygtP1swLTkuXSpbMC05XStbMC05Ll0qKS9nO1xuY29uc3QgdW5pdHNUZXN0ID0gL14tP1swLTkuXSpbMC05XStbMC05Ll0qJC9nO1xuZnVuY3Rpb24gY2FsY3VsYXRlU2l6ZSQxKHNpemUsIHJhdGlvLCBwcmVjaXNpb24pIHtcbiAgaWYgKHJhdGlvID09PSAxKSB7XG4gICAgcmV0dXJuIHNpemU7XG4gIH1cbiAgcHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDEwMDtcbiAgaWYgKHR5cGVvZiBzaXplID09PSBcIm51bWJlclwiKSB7XG4gICAgcmV0dXJuIE1hdGguY2VpbChzaXplICogcmF0aW8gKiBwcmVjaXNpb24pIC8gcHJlY2lzaW9uO1xuICB9XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBzaXplO1xuICB9XG4gIGNvbnN0IG9sZFBhcnRzID0gc2l6ZS5zcGxpdCh1bml0c1NwbGl0KTtcbiAgaWYgKG9sZFBhcnRzID09PSBudWxsIHx8ICFvbGRQYXJ0cy5sZW5ndGgpIHtcbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxuICBjb25zdCBuZXdQYXJ0cyA9IFtdO1xuICBsZXQgY29kZSA9IG9sZFBhcnRzLnNoaWZ0KCk7XG4gIGxldCBpc051bWJlciA9IHVuaXRzVGVzdC50ZXN0KGNvZGUpO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGlmIChpc051bWJlcikge1xuICAgICAgY29uc3QgbnVtID0gcGFyc2VGbG9hdChjb2RlKTtcbiAgICAgIGlmIChpc05hTihudW0pKSB7XG4gICAgICAgIG5ld1BhcnRzLnB1c2goY29kZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdQYXJ0cy5wdXNoKE1hdGguY2VpbChudW0gKiByYXRpbyAqIHByZWNpc2lvbikgLyBwcmVjaXNpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBuZXdQYXJ0cy5wdXNoKGNvZGUpO1xuICAgIH1cbiAgICBjb2RlID0gb2xkUGFydHMuc2hpZnQoKTtcbiAgICBpZiAoY29kZSA9PT0gdm9pZCAwKSB7XG4gICAgICByZXR1cm4gbmV3UGFydHMuam9pbihcIlwiKTtcbiAgICB9XG4gICAgaXNOdW1iZXIgPSAhaXNOdW1iZXI7XG4gIH1cbn1cblxuY29uc3QgaXNVbnNldEtleXdvcmQgPSAodmFsdWUpID0+IHZhbHVlID09PSBcInVuc2V0XCIgfHwgdmFsdWUgPT09IFwidW5kZWZpbmVkXCIgfHwgdmFsdWUgPT09IFwibm9uZVwiO1xuZnVuY3Rpb24gaWNvblRvU1ZHKGljb24sIGN1c3RvbWlzYXRpb25zKSB7XG4gIGNvbnN0IGZ1bGxJY29uID0ge1xuICAgIC4uLmRlZmF1bHRJY29uUHJvcHMsXG4gICAgLi4uaWNvblxuICB9O1xuICBjb25zdCBmdWxsQ3VzdG9taXNhdGlvbnMgPSB7XG4gICAgLi4uZGVmYXVsdEljb25DdXN0b21pc2F0aW9ucyxcbiAgICAuLi5jdXN0b21pc2F0aW9uc1xuICB9O1xuICBjb25zdCBib3ggPSB7XG4gICAgbGVmdDogZnVsbEljb24ubGVmdCxcbiAgICB0b3A6IGZ1bGxJY29uLnRvcCxcbiAgICB3aWR0aDogZnVsbEljb24ud2lkdGgsXG4gICAgaGVpZ2h0OiBmdWxsSWNvbi5oZWlnaHRcbiAgfTtcbiAgbGV0IGJvZHkgPSBmdWxsSWNvbi5ib2R5O1xuICBbZnVsbEljb24sIGZ1bGxDdXN0b21pc2F0aW9uc10uZm9yRWFjaCgocHJvcHMpID0+IHtcbiAgICBjb25zdCB0cmFuc2Zvcm1hdGlvbnMgPSBbXTtcbiAgICBjb25zdCBoRmxpcCA9IHByb3BzLmhGbGlwO1xuICAgIGNvbnN0IHZGbGlwID0gcHJvcHMudkZsaXA7XG4gICAgbGV0IHJvdGF0aW9uID0gcHJvcHMucm90YXRlO1xuICAgIGlmIChoRmxpcCkge1xuICAgICAgaWYgKHZGbGlwKSB7XG4gICAgICAgIHJvdGF0aW9uICs9IDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cmFuc2Zvcm1hdGlvbnMucHVzaChcbiAgICAgICAgICBcInRyYW5zbGF0ZShcIiArIChib3gud2lkdGggKyBib3gubGVmdCkudG9TdHJpbmcoKSArIFwiIFwiICsgKDAgLSBib3gudG9wKS50b1N0cmluZygpICsgXCIpXCJcbiAgICAgICAgKTtcbiAgICAgICAgdHJhbnNmb3JtYXRpb25zLnB1c2goXCJzY2FsZSgtMSAxKVwiKTtcbiAgICAgICAgYm94LnRvcCA9IGJveC5sZWZ0ID0gMDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHZGbGlwKSB7XG4gICAgICB0cmFuc2Zvcm1hdGlvbnMucHVzaChcbiAgICAgICAgXCJ0cmFuc2xhdGUoXCIgKyAoMCAtIGJveC5sZWZ0KS50b1N0cmluZygpICsgXCIgXCIgKyAoYm94LmhlaWdodCArIGJveC50b3ApLnRvU3RyaW5nKCkgKyBcIilcIlxuICAgICAgKTtcbiAgICAgIHRyYW5zZm9ybWF0aW9ucy5wdXNoKFwic2NhbGUoMSAtMSlcIik7XG4gICAgICBib3gudG9wID0gYm94LmxlZnQgPSAwO1xuICAgIH1cbiAgICBsZXQgdGVtcFZhbHVlO1xuICAgIGlmIChyb3RhdGlvbiA8IDApIHtcbiAgICAgIHJvdGF0aW9uIC09IE1hdGguZmxvb3Iocm90YXRpb24gLyA0KSAqIDQ7XG4gICAgfVxuICAgIHJvdGF0aW9uID0gcm90YXRpb24gJSA0O1xuICAgIHN3aXRjaCAocm90YXRpb24pIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgdGVtcFZhbHVlID0gYm94LmhlaWdodCAvIDIgKyBib3gudG9wO1xuICAgICAgICB0cmFuc2Zvcm1hdGlvbnMudW5zaGlmdChcbiAgICAgICAgICBcInJvdGF0ZSg5MCBcIiArIHRlbXBWYWx1ZS50b1N0cmluZygpICsgXCIgXCIgKyB0ZW1wVmFsdWUudG9TdHJpbmcoKSArIFwiKVwiXG4gICAgICAgICk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICB0cmFuc2Zvcm1hdGlvbnMudW5zaGlmdChcbiAgICAgICAgICBcInJvdGF0ZSgxODAgXCIgKyAoYm94LndpZHRoIC8gMiArIGJveC5sZWZ0KS50b1N0cmluZygpICsgXCIgXCIgKyAoYm94LmhlaWdodCAvIDIgKyBib3gudG9wKS50b1N0cmluZygpICsgXCIpXCJcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHRlbXBWYWx1ZSA9IGJveC53aWR0aCAvIDIgKyBib3gubGVmdDtcbiAgICAgICAgdHJhbnNmb3JtYXRpb25zLnVuc2hpZnQoXG4gICAgICAgICAgXCJyb3RhdGUoLTkwIFwiICsgdGVtcFZhbHVlLnRvU3RyaW5nKCkgKyBcIiBcIiArIHRlbXBWYWx1ZS50b1N0cmluZygpICsgXCIpXCJcbiAgICAgICAgKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGlmIChyb3RhdGlvbiAlIDIgPT09IDEpIHtcbiAgICAgIGlmIChib3gubGVmdCAhPT0gYm94LnRvcCkge1xuICAgICAgICB0ZW1wVmFsdWUgPSBib3gubGVmdDtcbiAgICAgICAgYm94LmxlZnQgPSBib3gudG9wO1xuICAgICAgICBib3gudG9wID0gdGVtcFZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGJveC53aWR0aCAhPT0gYm94LmhlaWdodCkge1xuICAgICAgICB0ZW1wVmFsdWUgPSBib3gud2lkdGg7XG4gICAgICAgIGJveC53aWR0aCA9IGJveC5oZWlnaHQ7XG4gICAgICAgIGJveC5oZWlnaHQgPSB0ZW1wVmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0cmFuc2Zvcm1hdGlvbnMubGVuZ3RoKSB7XG4gICAgICBib2R5ID0gJzxnIHRyYW5zZm9ybT1cIicgKyB0cmFuc2Zvcm1hdGlvbnMuam9pbihcIiBcIikgKyAnXCI+JyArIGJvZHkgKyBcIjwvZz5cIjtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBjdXN0b21pc2F0aW9uc1dpZHRoID0gZnVsbEN1c3RvbWlzYXRpb25zLndpZHRoO1xuICBjb25zdCBjdXN0b21pc2F0aW9uc0hlaWdodCA9IGZ1bGxDdXN0b21pc2F0aW9ucy5oZWlnaHQ7XG4gIGNvbnN0IGJveFdpZHRoID0gYm94LndpZHRoO1xuICBjb25zdCBib3hIZWlnaHQgPSBib3guaGVpZ2h0O1xuICBsZXQgd2lkdGg7XG4gIGxldCBoZWlnaHQ7XG4gIGlmIChjdXN0b21pc2F0aW9uc1dpZHRoID09PSBudWxsKSB7XG4gICAgaGVpZ2h0ID0gY3VzdG9taXNhdGlvbnNIZWlnaHQgPT09IG51bGwgPyBcIjFlbVwiIDogY3VzdG9taXNhdGlvbnNIZWlnaHQgPT09IFwiYXV0b1wiID8gYm94SGVpZ2h0IDogY3VzdG9taXNhdGlvbnNIZWlnaHQ7XG4gICAgd2lkdGggPSBjYWxjdWxhdGVTaXplJDEoaGVpZ2h0LCBib3hXaWR0aCAvIGJveEhlaWdodCk7XG4gIH0gZWxzZSB7XG4gICAgd2lkdGggPSBjdXN0b21pc2F0aW9uc1dpZHRoID09PSBcImF1dG9cIiA/IGJveFdpZHRoIDogY3VzdG9taXNhdGlvbnNXaWR0aDtcbiAgICBoZWlnaHQgPSBjdXN0b21pc2F0aW9uc0hlaWdodCA9PT0gbnVsbCA/IGNhbGN1bGF0ZVNpemUkMSh3aWR0aCwgYm94SGVpZ2h0IC8gYm94V2lkdGgpIDogY3VzdG9taXNhdGlvbnNIZWlnaHQgPT09IFwiYXV0b1wiID8gYm94SGVpZ2h0IDogY3VzdG9taXNhdGlvbnNIZWlnaHQ7XG4gIH1cbiAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xuICBjb25zdCBzZXRBdHRyID0gKHByb3AsIHZhbHVlKSA9PiB7XG4gICAgaWYgKCFpc1Vuc2V0S2V5d29yZCh2YWx1ZSkpIHtcbiAgICAgIGF0dHJpYnV0ZXNbcHJvcF0gPSB2YWx1ZS50b1N0cmluZygpO1xuICAgIH1cbiAgfTtcbiAgc2V0QXR0cihcIndpZHRoXCIsIHdpZHRoKTtcbiAgc2V0QXR0cihcImhlaWdodFwiLCBoZWlnaHQpO1xuICBhdHRyaWJ1dGVzLnZpZXdCb3ggPSBib3gubGVmdC50b1N0cmluZygpICsgXCIgXCIgKyBib3gudG9wLnRvU3RyaW5nKCkgKyBcIiBcIiArIGJveFdpZHRoLnRvU3RyaW5nKCkgKyBcIiBcIiArIGJveEhlaWdodC50b1N0cmluZygpO1xuICByZXR1cm4ge1xuICAgIGF0dHJpYnV0ZXMsXG4gICAgYm9keVxuICB9O1xufVxuXG5jb25zdCBkZXRlY3RGZXRjaCA9ICgpID0+IHtcbiAgbGV0IGNhbGxiYWNrO1xuICB0cnkge1xuICAgIGNhbGxiYWNrID0gZmV0Y2g7XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gY2FsbGJhY2s7XG4gICAgfVxuICB9IGNhdGNoIChlcnIpIHtcbiAgfVxufTtcbmxldCBmZXRjaE1vZHVsZSA9IGRldGVjdEZldGNoKCk7XG5mdW5jdGlvbiBzZXRGZXRjaChmZXRjaDIpIHtcbiAgZmV0Y2hNb2R1bGUgPSBmZXRjaDI7XG59XG5mdW5jdGlvbiBnZXRGZXRjaCgpIHtcbiAgcmV0dXJuIGZldGNoTW9kdWxlO1xufVxuZnVuY3Rpb24gY2FsY3VsYXRlTWF4TGVuZ3RoKHByb3ZpZGVyLCBwcmVmaXgpIHtcbiAgY29uc3QgY29uZmlnID0gZ2V0QVBJQ29uZmlnKHByb3ZpZGVyKTtcbiAgaWYgKCFjb25maWcpIHtcbiAgICByZXR1cm4gMDtcbiAgfVxuICBsZXQgcmVzdWx0O1xuICBpZiAoIWNvbmZpZy5tYXhVUkwpIHtcbiAgICByZXN1bHQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGxldCBtYXhIb3N0TGVuZ3RoID0gMDtcbiAgICBjb25maWcucmVzb3VyY2VzLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgIGNvbnN0IGhvc3QgPSBpdGVtO1xuICAgICAgbWF4SG9zdExlbmd0aCA9IE1hdGgubWF4KG1heEhvc3RMZW5ndGgsIGhvc3QubGVuZ3RoKTtcbiAgICB9KTtcbiAgICBjb25zdCB1cmwgPSBwcmVmaXggKyBcIi5qc29uP2ljb25zPVwiO1xuICAgIHJlc3VsdCA9IGNvbmZpZy5tYXhVUkwgLSBtYXhIb3N0TGVuZ3RoIC0gY29uZmlnLnBhdGgubGVuZ3RoIC0gdXJsLmxlbmd0aDtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gc2hvdWxkQWJvcnQoc3RhdHVzKSB7XG4gIHJldHVybiBzdGF0dXMgPT09IDQwNDtcbn1cbmNvbnN0IHByZXBhcmUgPSAocHJvdmlkZXIsIHByZWZpeCwgaWNvbnMpID0+IHtcbiAgY29uc3QgcmVzdWx0cyA9IFtdO1xuICBjb25zdCBtYXhMZW5ndGggPSBjYWxjdWxhdGVNYXhMZW5ndGgocHJvdmlkZXIsIHByZWZpeCk7XG4gIGNvbnN0IHR5cGUgPSBcImljb25zXCI7XG4gIGxldCBpdGVtID0ge1xuICAgIHR5cGUsXG4gICAgcHJvdmlkZXIsXG4gICAgcHJlZml4LFxuICAgIGljb25zOiBbXVxuICB9O1xuICBsZXQgbGVuZ3RoID0gMDtcbiAgaWNvbnMuZm9yRWFjaCgobmFtZSwgaW5kZXgpID0+IHtcbiAgICBsZW5ndGggKz0gbmFtZS5sZW5ndGggKyAxO1xuICAgIGlmIChsZW5ndGggPj0gbWF4TGVuZ3RoICYmIGluZGV4ID4gMCkge1xuICAgICAgcmVzdWx0cy5wdXNoKGl0ZW0pO1xuICAgICAgaXRlbSA9IHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcHJvdmlkZXIsXG4gICAgICAgIHByZWZpeCxcbiAgICAgICAgaWNvbnM6IFtdXG4gICAgICB9O1xuICAgICAgbGVuZ3RoID0gbmFtZS5sZW5ndGg7XG4gICAgfVxuICAgIGl0ZW0uaWNvbnMucHVzaChuYW1lKTtcbiAgfSk7XG4gIHJlc3VsdHMucHVzaChpdGVtKTtcbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuZnVuY3Rpb24gZ2V0UGF0aChwcm92aWRlcikge1xuICBpZiAodHlwZW9mIHByb3ZpZGVyID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29uc3QgY29uZmlnID0gZ2V0QVBJQ29uZmlnKHByb3ZpZGVyKTtcbiAgICBpZiAoY29uZmlnKSB7XG4gICAgICByZXR1cm4gY29uZmlnLnBhdGg7XG4gICAgfVxuICB9XG4gIHJldHVybiBcIi9cIjtcbn1cbmNvbnN0IHNlbmQgPSAoaG9zdCwgcGFyYW1zLCBjYWxsYmFjaykgPT4ge1xuICBpZiAoIWZldGNoTW9kdWxlKSB7XG4gICAgY2FsbGJhY2soXCJhYm9ydFwiLCA0MjQpO1xuICAgIHJldHVybjtcbiAgfVxuICBsZXQgcGF0aCA9IGdldFBhdGgocGFyYW1zLnByb3ZpZGVyKTtcbiAgc3dpdGNoIChwYXJhbXMudHlwZSkge1xuICAgIGNhc2UgXCJpY29uc1wiOiB7XG4gICAgICBjb25zdCBwcmVmaXggPSBwYXJhbXMucHJlZml4O1xuICAgICAgY29uc3QgaWNvbnMgPSBwYXJhbXMuaWNvbnM7XG4gICAgICBjb25zdCBpY29uc0xpc3QgPSBpY29ucy5qb2luKFwiLFwiKTtcbiAgICAgIGNvbnN0IHVybFBhcmFtcyA9IG5ldyBVUkxTZWFyY2hQYXJhbXMoe1xuICAgICAgICBpY29uczogaWNvbnNMaXN0XG4gICAgICB9KTtcbiAgICAgIHBhdGggKz0gcHJlZml4ICsgXCIuanNvbj9cIiArIHVybFBhcmFtcy50b1N0cmluZygpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIGNhc2UgXCJjdXN0b21cIjoge1xuICAgICAgY29uc3QgdXJpID0gcGFyYW1zLnVyaTtcbiAgICAgIHBhdGggKz0gdXJpLnNsaWNlKDAsIDEpID09PSBcIi9cIiA/IHVyaS5zbGljZSgxKSA6IHVyaTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBkZWZhdWx0OlxuICAgICAgY2FsbGJhY2soXCJhYm9ydFwiLCA0MDApO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIGxldCBkZWZhdWx0RXJyb3IgPSA1MDM7XG4gIGZldGNoTW9kdWxlKGhvc3QgKyBwYXRoKS50aGVuKChyZXNwb25zZSkgPT4ge1xuICAgIGNvbnN0IHN0YXR1cyA9IHJlc3BvbnNlLnN0YXR1cztcbiAgICBpZiAoc3RhdHVzICE9PSAyMDApIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICBjYWxsYmFjayhzaG91bGRBYm9ydChzdGF0dXMpID8gXCJhYm9ydFwiIDogXCJuZXh0XCIsIHN0YXR1cyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVmYXVsdEVycm9yID0gNTAxO1xuICAgIHJldHVybiByZXNwb25zZS5qc29uKCk7XG4gIH0pLnRoZW4oKGRhdGEpID0+IHtcbiAgICBpZiAodHlwZW9mIGRhdGEgIT09IFwib2JqZWN0XCIgfHwgZGF0YSA9PT0gbnVsbCkge1xuICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIGlmIChkYXRhID09PSA0MDQpIHtcbiAgICAgICAgICBjYWxsYmFjayhcImFib3J0XCIsIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNhbGxiYWNrKFwibmV4dFwiLCBkZWZhdWx0RXJyb3IpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICBjYWxsYmFjayhcInN1Y2Nlc3NcIiwgZGF0YSk7XG4gICAgfSk7XG4gIH0pLmNhdGNoKCgpID0+IHtcbiAgICBjYWxsYmFjayhcIm5leHRcIiwgZGVmYXVsdEVycm9yKTtcbiAgfSk7XG59O1xuY29uc3QgZmV0Y2hBUElNb2R1bGUgPSB7XG4gIHByZXBhcmUsXG4gIHNlbmRcbn07XG5cbmZ1bmN0aW9uIHRvZ2dsZUJyb3dzZXJDYWNoZShzdG9yYWdlLCB2YWx1ZSkge1xuICBzd2l0Y2ggKHN0b3JhZ2UpIHtcbiAgICBjYXNlIFwibG9jYWxcIjpcbiAgICBjYXNlIFwic2Vzc2lvblwiOlxuICAgICAgYnJvd3NlclN0b3JhZ2VDb25maWdbc3RvcmFnZV0gPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJhbGxcIjpcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIGJyb3dzZXJTdG9yYWdlQ29uZmlnKSB7XG4gICAgICAgIGJyb3dzZXJTdG9yYWdlQ29uZmlnW2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICB9XG59XG5cbi8qKlxuICogQXR0cmlidXRlIHRvIGFkZFxuICovXG5jb25zdCBub2RlQXR0ciA9ICdkYXRhLXN0eWxlJztcbi8qKlxuICogQ3VzdG9tIHN0eWxlIHRvIGFkZCB0byBlYWNoIG5vZGVcbiAqL1xubGV0IGN1c3RvbVN0eWxlID0gJyc7XG4vKipcbiAqIFNldCBjdXN0b20gc3R5bGUgdG8gYWRkIHRvIGFsbCBjb21wb25lbnRzXG4gKlxuICogQWZmZWN0cyBvbmx5IGNvbXBvbmVudHMgcmVuZGVyZWQgYWZ0ZXIgZnVuY3Rpb24gY2FsbFxuICovXG5mdW5jdGlvbiBhcHBlbmRDdXN0b21TdHlsZShzdHlsZSkge1xuICAgIGN1c3RvbVN0eWxlID0gc3R5bGU7XG59XG4vKipcbiAqIEFkZC91cGRhdGUgc3R5bGUgbm9kZVxuICovXG5mdW5jdGlvbiB1cGRhdGVTdHlsZShwYXJlbnQsIGlubGluZSkge1xuICAgIC8vIEdldCBub2RlLCBjcmVhdGUgaWYgbmVlZGVkXG4gICAgbGV0IHN0eWxlTm9kZSA9IEFycmF5LmZyb20ocGFyZW50LmNoaWxkTm9kZXMpLmZpbmQoKG5vZGUpID0+IG5vZGUuaGFzQXR0cmlidXRlICYmXG4gICAgICAgIG5vZGUuaGFzQXR0cmlidXRlKG5vZGVBdHRyKSk7XG4gICAgaWYgKCFzdHlsZU5vZGUpIHtcbiAgICAgICAgc3R5bGVOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgc3R5bGVOb2RlLnNldEF0dHJpYnV0ZShub2RlQXR0ciwgbm9kZUF0dHIpO1xuICAgICAgICBwYXJlbnQuYXBwZW5kQ2hpbGQoc3R5bGVOb2RlKTtcbiAgICB9XG4gICAgLy8gVXBkYXRlIGNvbnRlbnRcbiAgICBzdHlsZU5vZGUudGV4dENvbnRlbnQgPVxuICAgICAgICAnOmhvc3R7ZGlzcGxheTppbmxpbmUtYmxvY2s7dmVydGljYWwtYWxpZ246JyArXG4gICAgICAgICAgICAoaW5saW5lID8gJy0wLjEyNWVtJyA6ICcwJykgK1xuICAgICAgICAgICAgJ31zcGFuLHN2Z3tkaXNwbGF5OmJsb2NrfScgK1xuICAgICAgICAgICAgY3VzdG9tU3R5bGU7XG59XG5cbi8vIENvcmVcbi8qKlxuICogR2V0IGZ1bmN0aW9ucyBhbmQgaW5pdGlhbGlzZSBzdHVmZlxuICovXG5mdW5jdGlvbiBleHBvcnRGdW5jdGlvbnMoKSB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGlzZSBzdHVmZlxuICAgICAqL1xuICAgIC8vIFNldCBBUEkgbW9kdWxlXG4gICAgc2V0QVBJTW9kdWxlKCcnLCBmZXRjaEFQSU1vZHVsZSk7XG4gICAgLy8gQWxsb3cgc2ltcGxlIGljb24gbmFtZXNcbiAgICBhbGxvd1NpbXBsZU5hbWVzKHRydWUpO1xuICAgIGxldCBfd2luZG93O1xuICAgIHRyeSB7XG4gICAgICAgIF93aW5kb3cgPSB3aW5kb3c7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgLy9cbiAgICB9XG4gICAgaWYgKF93aW5kb3cpIHtcbiAgICAgICAgLy8gU2V0IGNhY2hlIGFuZCBsb2FkIGV4aXN0aW5nIGNhY2hlXG4gICAgICAgIGluaXRCcm93c2VyU3RvcmFnZSgpO1xuICAgICAgICAvLyBMb2FkIGljb25zIGZyb20gZ2xvYmFsIFwiSWNvbmlmeVByZWxvYWRcIlxuICAgICAgICBpZiAoX3dpbmRvdy5JY29uaWZ5UHJlbG9hZCAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBjb25zdCBwcmVsb2FkID0gX3dpbmRvdy5JY29uaWZ5UHJlbG9hZDtcbiAgICAgICAgICAgIGNvbnN0IGVyciA9ICdJbnZhbGlkIEljb25pZnlQcmVsb2FkIHN5bnRheC4nO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcmVsb2FkID09PSAnb2JqZWN0JyAmJiBwcmVsb2FkICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgKHByZWxvYWQgaW5zdGFuY2VvZiBBcnJheSA/IHByZWxvYWQgOiBbcHJlbG9hZF0pLmZvckVhY2goKGl0ZW0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIGl0ZW0gaXMgYW4gb2JqZWN0IGFuZCBub3QgbnVsbC9hcnJheVxuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGl0ZW0gIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaXRlbSA9PT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0gaW5zdGFuY2VvZiBBcnJheSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGZvciAnaWNvbnMnIGFuZCAncHJlZml4J1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpdGVtLmljb25zICE9PSAnb2JqZWN0JyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGVvZiBpdGVtLnByZWZpeCAhPT0gJ3N0cmluZycgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGQgaWNvbiBzZXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAhYWRkQ29sbGVjdGlvbiQxKGl0ZW0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgQVBJIGZyb20gZ2xvYmFsIFwiSWNvbmlmeVByb3ZpZGVyc1wiXG4gICAgICAgIGlmIChfd2luZG93Lkljb25pZnlQcm92aWRlcnMgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXJzID0gX3dpbmRvdy5JY29uaWZ5UHJvdmlkZXJzO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcnMgPT09ICdvYmplY3QnICYmIHByb3ZpZGVycyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHByb3ZpZGVycykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnIgPSAnSWNvbmlmeVByb3ZpZGVyc1snICsga2V5ICsgJ10gaXMgaW52YWxpZC4nO1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwcm92aWRlcnNba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdvYmplY3QnIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIXZhbHVlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUucmVzb3VyY2VzID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWRkQVBJUHJvdmlkZXIkMShrZXksIHZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IF9hcGkgPSB7XG4gICAgICAgIGdldEFQSUNvbmZpZyxcbiAgICAgICAgc2V0QVBJTW9kdWxlLFxuICAgICAgICBzZW5kQVBJUXVlcnksXG4gICAgICAgIHNldEZldGNoLFxuICAgICAgICBnZXRGZXRjaCxcbiAgICAgICAgbGlzdEFQSVByb3ZpZGVycyxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuYWJsZUNhY2hlOiAoc3RvcmFnZSkgPT4gdG9nZ2xlQnJvd3NlckNhY2hlKHN0b3JhZ2UsIHRydWUpLFxuICAgICAgICBkaXNhYmxlQ2FjaGU6IChzdG9yYWdlKSA9PiB0b2dnbGVCcm93c2VyQ2FjaGUoc3RvcmFnZSwgZmFsc2UpLFxuICAgICAgICBpY29uRXhpc3RzOiBpY29uRXhpc3RzJDEsXG4gICAgICAgIGdldEljb246IGdldEljb24kMSxcbiAgICAgICAgbGlzdEljb25zOiBsaXN0SWNvbnMkMSxcbiAgICAgICAgYWRkSWNvbjogYWRkSWNvbiQxLFxuICAgICAgICBhZGRDb2xsZWN0aW9uOiBhZGRDb2xsZWN0aW9uJDEsXG4gICAgICAgIGNhbGN1bGF0ZVNpemU6IGNhbGN1bGF0ZVNpemUkMSxcbiAgICAgICAgYnVpbGRJY29uOiBpY29uVG9TVkcsXG4gICAgICAgIGxvYWRJY29uczogbG9hZEljb25zJDEsXG4gICAgICAgIGxvYWRJY29uOiBsb2FkSWNvbiQxLFxuICAgICAgICBhZGRBUElQcm92aWRlcjogYWRkQVBJUHJvdmlkZXIkMSxcbiAgICAgICAgYXBwZW5kQ3VzdG9tU3R5bGUsXG4gICAgICAgIF9hcGksXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaWNvblRvSFRNTChib2R5LCBhdHRyaWJ1dGVzKSB7XG4gIGxldCByZW5kZXJBdHRyaWJzSFRNTCA9IGJvZHkuaW5kZXhPZihcInhsaW5rOlwiKSA9PT0gLTEgPyBcIlwiIDogJyB4bWxuczp4bGluaz1cImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIic7XG4gIGZvciAoY29uc3QgYXR0ciBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgcmVuZGVyQXR0cmlic0hUTUwgKz0gXCIgXCIgKyBhdHRyICsgJz1cIicgKyBhdHRyaWJ1dGVzW2F0dHJdICsgJ1wiJztcbiAgfVxuICByZXR1cm4gJzxzdmcgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiJyArIHJlbmRlckF0dHJpYnNIVE1MICsgXCI+XCIgKyBib2R5ICsgXCI8L3N2Zz5cIjtcbn1cblxuZnVuY3Rpb24gZW5jb2RlU1ZHZm9yVVJMKHN2Zykge1xuICByZXR1cm4gc3ZnLnJlcGxhY2UoL1wiL2csIFwiJ1wiKS5yZXBsYWNlKC8lL2csIFwiJTI1XCIpLnJlcGxhY2UoLyMvZywgXCIlMjNcIikucmVwbGFjZSgvPC9nLCBcIiUzQ1wiKS5yZXBsYWNlKC8+L2csIFwiJTNFXCIpLnJlcGxhY2UoL1xccysvZywgXCIgXCIpO1xufVxuZnVuY3Rpb24gc3ZnVG9EYXRhKHN2Zykge1xuICByZXR1cm4gXCJkYXRhOmltYWdlL3N2Zyt4bWwsXCIgKyBlbmNvZGVTVkdmb3JVUkwoc3ZnKTtcbn1cbmZ1bmN0aW9uIHN2Z1RvVVJMKHN2Zykge1xuICByZXR1cm4gJ3VybChcIicgKyBzdmdUb0RhdGEoc3ZnKSArICdcIiknO1xufVxuXG4vLyBMaXN0IG9mIHByb3BlcnRpZXMgdG8gYXBwbHlcbmNvbnN0IG1vbm90b25lUHJvcHMgPSB7XG4gICAgJ2JhY2tncm91bmQtY29sb3InOiAnY3VycmVudENvbG9yJyxcbn07XG5jb25zdCBjb2xvcmVkUHJvcHMgPSB7XG4gICAgJ2JhY2tncm91bmQtY29sb3InOiAndHJhbnNwYXJlbnQnLFxufTtcbi8vIER5bmFtaWNhbGx5IGFkZCBjb21tb24gcHJvcHMgdG8gdmFyaWFibGVzIGFib3ZlXG5jb25zdCBwcm9wc1RvQWRkID0ge1xuICAgIGltYWdlOiAndmFyKC0tc3ZnKScsXG4gICAgcmVwZWF0OiAnbm8tcmVwZWF0JyxcbiAgICBzaXplOiAnMTAwJSAxMDAlJyxcbn07XG5jb25zdCBwcm9wc1RvQWRkVG8gPSB7XG4gICAgJy13ZWJraXQtbWFzayc6IG1vbm90b25lUHJvcHMsXG4gICAgJ21hc2snOiBtb25vdG9uZVByb3BzLFxuICAgICdiYWNrZ3JvdW5kJzogY29sb3JlZFByb3BzLFxufTtcbmZvciAoY29uc3QgcHJlZml4IGluIHByb3BzVG9BZGRUbykge1xuICAgIGNvbnN0IGxpc3QgPSBwcm9wc1RvQWRkVG9bcHJlZml4XTtcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gcHJvcHNUb0FkZCkge1xuICAgICAgICBsaXN0W3ByZWZpeCArICctJyArIHByb3BdID0gcHJvcHNUb0FkZFtwcm9wXTtcbiAgICB9XG59XG4vKipcbiAqIEZpeCBzaXplOiBhZGQgJ3B4JyB0byBudW1iZXJzXG4gKi9cbmZ1bmN0aW9uIGZpeFNpemUodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPyB2YWx1ZSArICh2YWx1ZS5tYXRjaCgvXlstMC05Ll0rJC8pID8gJ3B4JyA6ICcnKSA6ICdpbmhlcml0Jztcbn1cbi8qKlxuICogUmVuZGVyIG5vZGUgYXMgPHNwYW4+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNQQU4oZGF0YSwgaWNvbiwgdXNlTWFzaykge1xuICAgIGNvbnN0IG5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgLy8gQm9keVxuICAgIGxldCBib2R5ID0gZGF0YS5ib2R5O1xuICAgIGlmIChib2R5LmluZGV4T2YoJzxhJykgIT09IC0xKSB7XG4gICAgICAgIC8vIEFuaW1hdGVkIFNWRzogYWRkIHNvbWV0aGluZyB0byBmaXggdGltaW5nIGJ1Z1xuICAgICAgICBib2R5ICs9ICc8IS0tICcgKyBEYXRlLm5vdygpICsgJyAtLT4nO1xuICAgIH1cbiAgICAvLyBHZW5lcmF0ZSBTVkcgYXMgVVJMXG4gICAgY29uc3QgcmVuZGVyQXR0cmlicyA9IGRhdGEuYXR0cmlidXRlcztcbiAgICBjb25zdCBodG1sID0gaWNvblRvSFRNTChib2R5LCB7XG4gICAgICAgIC4uLnJlbmRlckF0dHJpYnMsXG4gICAgICAgIHdpZHRoOiBpY29uLndpZHRoICsgJycsXG4gICAgICAgIGhlaWdodDogaWNvbi5oZWlnaHQgKyAnJyxcbiAgICB9KTtcbiAgICBjb25zdCB1cmwgPSBzdmdUb1VSTChodG1sKTtcbiAgICAvLyBHZW5lcmF0ZSBzdHlsZVxuICAgIGNvbnN0IHN2Z1N0eWxlID0gbm9kZS5zdHlsZTtcbiAgICBjb25zdCBzdHlsZXMgPSB7XG4gICAgICAgICctLXN2Zyc6IHVybCxcbiAgICAgICAgJ3dpZHRoJzogZml4U2l6ZShyZW5kZXJBdHRyaWJzLndpZHRoKSxcbiAgICAgICAgJ2hlaWdodCc6IGZpeFNpemUocmVuZGVyQXR0cmlicy5oZWlnaHQpLFxuICAgICAgICAuLi4odXNlTWFzayA/IG1vbm90b25lUHJvcHMgOiBjb2xvcmVkUHJvcHMpLFxuICAgIH07XG4gICAgLy8gQXBwbHkgc3R5bGVcbiAgICBmb3IgKGNvbnN0IHByb3AgaW4gc3R5bGVzKSB7XG4gICAgICAgIHN2Z1N0eWxlLnNldFByb3BlcnR5KHByb3AsIHN0eWxlc1twcm9wXSk7XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufVxuXG5sZXQgcG9saWN5O1xuZnVuY3Rpb24gY3JlYXRlUG9saWN5KCkge1xuICB0cnkge1xuICAgIHBvbGljeSA9IHdpbmRvdy50cnVzdGVkVHlwZXMuY3JlYXRlUG9saWN5KFwiaWNvbmlmeVwiLCB7XG4gICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVuc2FmZS1yZXR1cm5cbiAgICAgIGNyZWF0ZUhUTUw6IChzKSA9PiBzXG4gICAgfSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIHBvbGljeSA9IG51bGw7XG4gIH1cbn1cbmZ1bmN0aW9uIGNsZWFuVXBJbm5lckhUTUwoaHRtbCkge1xuICBpZiAocG9saWN5ID09PSB2b2lkIDApIHtcbiAgICBjcmVhdGVQb2xpY3koKTtcbiAgfVxuICByZXR1cm4gcG9saWN5ID8gcG9saWN5LmNyZWF0ZUhUTUwoaHRtbCkgOiBodG1sO1xufVxuXG4vKipcbiAqIFJlbmRlciBub2RlIGFzIDxzdmc+XG4gKi9cbmZ1bmN0aW9uIHJlbmRlclNWRyhkYXRhKSB7XG4gICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAvLyBBZGQgc3R5bGUgaWYgbmVlZGVkXG4gICAgY29uc3QgYXR0ciA9IGRhdGEuYXR0cmlidXRlcztcbiAgICBsZXQgc3R5bGUgPSAnJztcbiAgICBpZiAoIWF0dHIud2lkdGgpIHtcbiAgICAgICAgc3R5bGUgPSAnd2lkdGg6IGluaGVyaXQ7JztcbiAgICB9XG4gICAgaWYgKCFhdHRyLmhlaWdodCkge1xuICAgICAgICBzdHlsZSArPSAnaGVpZ2h0OiBpbmhlcml0Oyc7XG4gICAgfVxuICAgIGlmIChzdHlsZSkge1xuICAgICAgICBhdHRyLnN0eWxlID0gc3R5bGU7XG4gICAgfVxuICAgIC8vIEdlbmVyYXRlIFNWR1xuICAgIGNvbnN0IGh0bWwgPSBpY29uVG9IVE1MKGRhdGEuYm9keSwgYXR0cik7XG4gICAgbm9kZS5pbm5lckhUTUwgPSBjbGVhblVwSW5uZXJIVE1MKGh0bWwpO1xuICAgIHJldHVybiBub2RlLmZpcnN0Q2hpbGQ7XG59XG5cbi8qKlxuICogUmVuZGVyIGljb25cbiAqL1xuZnVuY3Rpb24gcmVuZGVySWNvbihwYXJlbnQsIHN0YXRlKSB7XG4gICAgY29uc3QgaWNvbkRhdGEgPSBzdGF0ZS5pY29uLmRhdGE7XG4gICAgY29uc3QgY3VzdG9taXNhdGlvbnMgPSBzdGF0ZS5jdXN0b21pc2F0aW9ucztcbiAgICAvLyBSZW5kZXIgaWNvblxuICAgIGNvbnN0IHJlbmRlckRhdGEgPSBpY29uVG9TVkcoaWNvbkRhdGEsIGN1c3RvbWlzYXRpb25zKTtcbiAgICBpZiAoY3VzdG9taXNhdGlvbnMucHJlc2VydmVBc3BlY3RSYXRpbykge1xuICAgICAgICByZW5kZXJEYXRhLmF0dHJpYnV0ZXNbJ3ByZXNlcnZlQXNwZWN0UmF0aW8nXSA9XG4gICAgICAgICAgICBjdXN0b21pc2F0aW9ucy5wcmVzZXJ2ZUFzcGVjdFJhdGlvO1xuICAgIH1cbiAgICBjb25zdCBtb2RlID0gc3RhdGUucmVuZGVyZWRNb2RlO1xuICAgIGxldCBub2RlO1xuICAgIHN3aXRjaCAobW9kZSkge1xuICAgICAgICBjYXNlICdzdmcnOlxuICAgICAgICAgICAgbm9kZSA9IHJlbmRlclNWRyhyZW5kZXJEYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgbm9kZSA9IHJlbmRlclNQQU4ocmVuZGVyRGF0YSwge1xuICAgICAgICAgICAgICAgIC4uLmRlZmF1bHRJY29uUHJvcHMsXG4gICAgICAgICAgICAgICAgLi4uaWNvbkRhdGEsXG4gICAgICAgICAgICB9LCBtb2RlID09PSAnbWFzaycpO1xuICAgIH1cbiAgICAvLyBTZXQgZWxlbWVudFxuICAgIGNvbnN0IG9sZE5vZGUgPSBBcnJheS5mcm9tKHBhcmVudC5jaGlsZE5vZGVzKS5maW5kKChub2RlKSA9PiB7XG4gICAgICAgIGNvbnN0IHRhZyA9IG5vZGUudGFnTmFtZSAmJlxuICAgICAgICAgICAgbm9kZS50YWdOYW1lLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiB0YWcgPT09ICdTUEFOJyB8fCB0YWcgPT09ICdTVkcnO1xuICAgIH0pO1xuICAgIGlmIChvbGROb2RlKSB7XG4gICAgICAgIC8vIFJlcGxhY2Ugb2xkIGVsZW1lbnRcbiAgICAgICAgaWYgKG5vZGUudGFnTmFtZSA9PT0gJ1NQQU4nICYmIG9sZE5vZGUudGFnTmFtZSA9PT0gbm9kZS50YWdOYW1lKSB7XG4gICAgICAgICAgICAvLyBTd2FwIHN0eWxlIGluc3RlYWQgb2Ygd2hvbGUgbm9kZVxuICAgICAgICAgICAgb2xkTm9kZS5zZXRBdHRyaWJ1dGUoJ3N0eWxlJywgbm9kZS5nZXRBdHRyaWJ1dGUoJ3N0eWxlJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyZW50LnJlcGxhY2VDaGlsZChub2RlLCBvbGROb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLy8gQWRkIG5ldyBlbGVtZW50XG4gICAgICAgIHBhcmVudC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICB9XG59XG5cbi8qKlxuICogU2V0IHN0YXRlIHRvIFBlbmRpbmdTdGF0ZVxuICovXG5mdW5jdGlvbiBzZXRQZW5kaW5nU3RhdGUoaWNvbiwgaW5saW5lLCBsYXN0U3RhdGUpIHtcbiAgICBjb25zdCBsYXN0UmVuZGVyID0gbGFzdFN0YXRlICYmXG4gICAgICAgIChsYXN0U3RhdGUucmVuZGVyZWRcbiAgICAgICAgICAgID8gbGFzdFN0YXRlXG4gICAgICAgICAgICA6IGxhc3RTdGF0ZS5sYXN0UmVuZGVyKTtcbiAgICByZXR1cm4ge1xuICAgICAgICByZW5kZXJlZDogZmFsc2UsXG4gICAgICAgIGlubGluZSxcbiAgICAgICAgaWNvbixcbiAgICAgICAgbGFzdFJlbmRlcixcbiAgICB9O1xufVxuXG4vKipcbiAqIFJlZ2lzdGVyICdpY29uaWZ5LWljb24nIGNvbXBvbmVudCwgaWYgaXQgZG9lcyBub3QgZXhpc3RcbiAqL1xuZnVuY3Rpb24gZGVmaW5lSWNvbmlmeUljb24obmFtZSA9ICdpY29uaWZ5LWljb24nKSB7XG4gICAgLy8gQ2hlY2sgZm9yIGN1c3RvbSBlbGVtZW50cyByZWdpc3RyeSBhbmQgSFRNTEVsZW1lbnRcbiAgICBsZXQgY3VzdG9tRWxlbWVudHM7XG4gICAgbGV0IFBhcmVudENsYXNzO1xuICAgIHRyeSB7XG4gICAgICAgIGN1c3RvbUVsZW1lbnRzID0gd2luZG93LmN1c3RvbUVsZW1lbnRzO1xuICAgICAgICBQYXJlbnRDbGFzcyA9IHdpbmRvdy5IVE1MRWxlbWVudDtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSByZWdpc3RyeSBhbmQgSFRNTEVsZW1lbnQgZXhpc3RcbiAgICBpZiAoIWN1c3RvbUVsZW1lbnRzIHx8ICFQYXJlbnRDbGFzcykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIENoZWNrIGZvciBkdXBsaWNhdGVcbiAgICBjb25zdCBDb25mbGljdGluZ0NsYXNzID0gY3VzdG9tRWxlbWVudHMuZ2V0KG5hbWUpO1xuICAgIGlmIChDb25mbGljdGluZ0NsYXNzKSB7XG4gICAgICAgIHJldHVybiBDb25mbGljdGluZ0NsYXNzO1xuICAgIH1cbiAgICAvLyBBbGwgYXR0cmlidXRlc1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBbXG4gICAgICAgIC8vIEljb25cbiAgICAgICAgJ2ljb24nLFxuICAgICAgICAvLyBNb2RlXG4gICAgICAgICdtb2RlJyxcbiAgICAgICAgJ2lubGluZScsXG4gICAgICAgIC8vIEN1c3RvbWlzYXRpb25zXG4gICAgICAgICd3aWR0aCcsXG4gICAgICAgICdoZWlnaHQnLFxuICAgICAgICAncm90YXRlJyxcbiAgICAgICAgJ2ZsaXAnLFxuICAgIF07XG4gICAgLyoqXG4gICAgICogQ29tcG9uZW50IGNsYXNzXG4gICAgICovXG4gICAgY29uc3QgSWNvbmlmeUljb24gPSBjbGFzcyBleHRlbmRzIFBhcmVudENsYXNzIHtcbiAgICAgICAgLy8gUm9vdFxuICAgICAgICBfc2hhZG93Um9vdDtcbiAgICAgICAgLy8gU3RhdGVcbiAgICAgICAgX3N0YXRlO1xuICAgICAgICAvLyBBdHRyaWJ1dGVzIGNoZWNrIHF1ZXVlZFxuICAgICAgICBfY2hlY2tRdWV1ZWQgPSBmYWxzZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENvbnN0cnVjdG9yXG4gICAgICAgICAqL1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICAvLyBBdHRhY2ggc2hhZG93IERPTVxuICAgICAgICAgICAgY29uc3Qgcm9vdCA9ICh0aGlzLl9zaGFkb3dSb290ID0gdGhpcy5hdHRhY2hTaGFkb3coe1xuICAgICAgICAgICAgICAgIG1vZGU6ICdvcGVuJyxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIC8vIEFkZCBzdHlsZVxuICAgICAgICAgICAgY29uc3QgaW5saW5lID0gZ2V0SW5saW5lKHRoaXMpO1xuICAgICAgICAgICAgdXBkYXRlU3R5bGUocm9vdCwgaW5saW5lKTtcbiAgICAgICAgICAgIC8vIENyZWF0ZSBlbXB0eSBzdGF0ZVxuICAgICAgICAgICAgdGhpcy5fc3RhdGUgPSBzZXRQZW5kaW5nU3RhdGUoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiAnJyxcbiAgICAgICAgICAgIH0sIGlubGluZSk7XG4gICAgICAgICAgICAvLyBRdWV1ZSBpY29uIHJlbmRlclxuICAgICAgICAgICAgdGhpcy5fcXVldWVDaGVjaygpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPYnNlcnZlZCBhdHRyaWJ1dGVzXG4gICAgICAgICAqL1xuICAgICAgICBzdGF0aWMgZ2V0IG9ic2VydmVkQXR0cmlidXRlcygpIHtcbiAgICAgICAgICAgIHJldHVybiBhdHRyaWJ1dGVzLnNsaWNlKDApO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBPYnNlcnZlZCBwcm9wZXJ0aWVzIHRoYXQgYXJlIGRpZmZlcmVudCBmcm9tIGF0dHJpYnV0ZXNcbiAgICAgICAgICpcbiAgICAgICAgICogRXhwZXJpbWVudGFsISBOZWVkIHRvIHRlc3Qgd2l0aCB2YXJpb3VzIGZyYW1ld29ya3MgdGhhdCBzdXBwb3J0IGl0XG4gICAgICAgICAqL1xuICAgICAgICAvKlxuICAgICAgICBzdGF0aWMgZ2V0IHByb3BlcnRpZXMoKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGlubGluZToge1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBCb29sZWFuLFxuICAgICAgICAgICAgICAgICAgICByZWZsZWN0OiB0cnVlLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gTm90IGxpc3Rpbmcgb3RoZXIgYXR0cmlidXRlcyBiZWNhdXNlIHRoZXkgYXJlIHN0cmluZ3Mgb3IgY29tYmluYXRpb25cbiAgICAgICAgICAgICAgICAvLyBvZiBzdHJpbmcgYW5kIGFub3RoZXIgdHlwZS4gQ2Fubm90IGhhdmUgbXVsdGlwbGUgdHlwZXNcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgKi9cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEF0dHJpYnV0ZSBoYXMgY2hhbmdlZFxuICAgICAgICAgKi9cbiAgICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKG5hbWUpIHtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnaW5saW5lJykge1xuICAgICAgICAgICAgICAgIC8vIFVwZGF0ZSBpbW1lZGlhdGVseTogbm90IGFmZmVjdGVkIGJ5IG90aGVyIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdJbmxpbmUgPSBnZXRJbmxpbmUodGhpcyk7XG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAobmV3SW5saW5lICE9PSBzdGF0ZS5pbmxpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHN0eWxlIGlmIGlubGluZSBtb2RlIGNoYW5nZWRcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaW5saW5lID0gbmV3SW5saW5lO1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVTdHlsZSh0aGlzLl9zaGFkb3dSb290LCBuZXdJbmxpbmUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFF1ZXVlIGNoZWNrIGZvciBvdGhlciBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWVDaGVjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQvc2V0IGljb25cbiAgICAgICAgICovXG4gICAgICAgIGdldCBpY29uKCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnaWNvbicpO1xuICAgICAgICAgICAgaWYgKHZhbHVlICYmIHZhbHVlLnNsaWNlKDAsIDEpID09PSAneycpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZSh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgc2V0IGljb24odmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnaWNvbicsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogR2V0L3NldCBpbmxpbmVcbiAgICAgICAgICovXG4gICAgICAgIGdldCBpbmxpbmUoKSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0SW5saW5lKHRoaXMpO1xuICAgICAgICB9XG4gICAgICAgIHNldCBpbmxpbmUodmFsdWUpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0QXR0cmlidXRlKCdpbmxpbmUnLCAndHJ1ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVBdHRyaWJ1dGUoJ2lubGluZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZXN0YXJ0IGFuaW1hdGlvblxuICAgICAgICAgKi9cbiAgICAgICAgcmVzdGFydEFuaW1hdGlvbigpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXRlID0gdGhpcy5fc3RhdGU7XG4gICAgICAgICAgICBpZiAoc3RhdGUucmVuZGVyZWQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByb290ID0gdGhpcy5fc2hhZG93Um9vdDtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUucmVuZGVyZWRNb2RlID09PSAnc3ZnJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBVcGRhdGUgcm9vdCBub2RlXG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByb290Lmxhc3RDaGlsZC5zZXRDdXJyZW50VGltZSgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBGYWlsZWQ6IHNldEN1cnJlbnRUaW1lKCkgaXMgbm90IHN1cHBvcnRlZFxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlbmRlckljb24ocm9vdCwgc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHZXQgc3RhdHVzXG4gICAgICAgICAqL1xuICAgICAgICBnZXQgc3RhdHVzKCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgICAgIHJldHVybiBzdGF0ZS5yZW5kZXJlZFxuICAgICAgICAgICAgICAgID8gJ3JlbmRlcmVkJ1xuICAgICAgICAgICAgICAgIDogc3RhdGUuaWNvbi5kYXRhID09PSBudWxsXG4gICAgICAgICAgICAgICAgICAgID8gJ2ZhaWxlZCdcbiAgICAgICAgICAgICAgICAgICAgOiAnbG9hZGluZyc7XG4gICAgICAgIH1cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFF1ZXVlIGF0dHJpYnV0ZXMgcmUtY2hlY2tcbiAgICAgICAgICovXG4gICAgICAgIF9xdWV1ZUNoZWNrKCkge1xuICAgICAgICAgICAgaWYgKCF0aGlzLl9jaGVja1F1ZXVlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NoZWNrUXVldWVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fY2hlY2soKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogQ2hlY2sgZm9yIGNoYW5nZXNcbiAgICAgICAgICovXG4gICAgICAgIF9jaGVjaygpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fY2hlY2tRdWV1ZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9jaGVja1F1ZXVlZCA9IGZhbHNlO1xuICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgICAgIC8vIEdldCBpY29uXG4gICAgICAgICAgICBjb25zdCBuZXdJY29uID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2ljb24nKTtcbiAgICAgICAgICAgIGlmIChuZXdJY29uICE9PSBzdGF0ZS5pY29uLnZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5faWNvbkNoYW5nZWQobmV3SWNvbik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWdub3JlIG90aGVyIGF0dHJpYnV0ZXMgaWYgaWNvbiBpcyBub3QgcmVuZGVyZWRcbiAgICAgICAgICAgIGlmICghc3RhdGUucmVuZGVyZWQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBmb3IgbW9kZSBhbmQgYXR0cmlidXRlIGNoYW5nZXNcbiAgICAgICAgICAgIGNvbnN0IG1vZGUgPSB0aGlzLmdldEF0dHJpYnV0ZSgnbW9kZScpO1xuICAgICAgICAgICAgY29uc3QgY3VzdG9taXNhdGlvbnMgPSBnZXRDdXN0b21pc2F0aW9ucyh0aGlzKTtcbiAgICAgICAgICAgIGlmIChzdGF0ZS5hdHRyTW9kZSAhPT0gbW9kZSB8fFxuICAgICAgICAgICAgICAgIGhhdmVDdXN0b21pc2F0aW9uc0NoYW5nZWQoc3RhdGUuY3VzdG9taXNhdGlvbnMsIGN1c3RvbWlzYXRpb25zKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlckljb24oc3RhdGUuaWNvbiwgY3VzdG9taXNhdGlvbnMsIG1vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJY29uIHZhbHVlIGhhcyBjaGFuZ2VkXG4gICAgICAgICAqL1xuICAgICAgICBfaWNvbkNoYW5nZWQobmV3VmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGljb24gPSBwYXJzZUljb25WYWx1ZShuZXdWYWx1ZSwgKHZhbHVlLCBuYW1lLCBkYXRhKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gQXN5bmNocm9ub3VzIGNhbGxiYWNrOiByZS1jaGVjayB2YWx1ZXMgdG8gbWFrZSBzdXJlIHN0dWZmIHdhc24ndCBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAoc3RhdGUucmVuZGVyZWQgfHwgdGhpcy5nZXRBdHRyaWJ1dGUoJ2ljb24nKSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSWNvbiBkYXRhIGlzIGFscmVhZHkgYXZhaWxhYmxlIG9yIGljb24gYXR0cmlidXRlIHdhcyBjaGFuZ2VkXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQ2hhbmdlIGljb25cbiAgICAgICAgICAgICAgICBjb25zdCBpY29uID0ge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmIChpY29uLmRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVuZGVyIGljb25cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ290SWNvbkRhdGEoaWNvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3RoaW5nIHRvIHJlbmRlcjogdXBkYXRlIGljb24gaW4gc3RhdGVcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUuaWNvbiA9IGljb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoaWNvbi5kYXRhKSB7XG4gICAgICAgICAgICAgICAgLy8gSWNvbiBpcyByZWFkeSB0byByZW5kZXJcbiAgICAgICAgICAgICAgICB0aGlzLl9nb3RJY29uRGF0YShpY29uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIFBlbmRpbmcgaWNvblxuICAgICAgICAgICAgICAgIHRoaXMuX3N0YXRlID0gc2V0UGVuZGluZ1N0YXRlKGljb24sIHRoaXMuX3N0YXRlLmlubGluZSwgdGhpcy5fc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBHb3QgbmV3IGljb24gZGF0YSwgaWNvbiBpcyByZWFkeSB0byAocmUpcmVuZGVyXG4gICAgICAgICAqL1xuICAgICAgICBfZ290SWNvbkRhdGEoaWNvbikge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tRdWV1ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlckljb24oaWNvbiwgZ2V0Q3VzdG9taXNhdGlvbnModGhpcyksIHRoaXMuZ2V0QXR0cmlidXRlKCdtb2RlJykpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZS1yZW5kZXIgYmFzZWQgb24gaWNvbiBkYXRhXG4gICAgICAgICAqL1xuICAgICAgICBfcmVuZGVySWNvbihpY29uLCBjdXN0b21pc2F0aW9ucywgYXR0ck1vZGUpIHtcbiAgICAgICAgICAgIC8vIEdldCBtb2RlXG4gICAgICAgICAgICBjb25zdCByZW5kZXJlZE1vZGUgPSBnZXRSZW5kZXJNb2RlKGljb24uZGF0YS5ib2R5LCBhdHRyTW9kZSk7XG4gICAgICAgICAgICAvLyBJbmxpbmUgd2FzIG5vdCBjaGFuZ2VkXG4gICAgICAgICAgICBjb25zdCBpbmxpbmUgPSB0aGlzLl9zdGF0ZS5pbmxpbmU7XG4gICAgICAgICAgICAvLyBTZXQgc3RhdGUgYW5kIHJlbmRlclxuICAgICAgICAgICAgcmVuZGVySWNvbih0aGlzLl9zaGFkb3dSb290LCAodGhpcy5fc3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgcmVuZGVyZWQ6IHRydWUsXG4gICAgICAgICAgICAgICAgaWNvbixcbiAgICAgICAgICAgICAgICBpbmxpbmUsXG4gICAgICAgICAgICAgICAgY3VzdG9taXNhdGlvbnMsXG4gICAgICAgICAgICAgICAgYXR0ck1vZGUsXG4gICAgICAgICAgICAgICAgcmVuZGVyZWRNb2RlLFxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBBZGQgZ2V0dGVycyBhbmQgc2V0dGVyc1xuICAgIGF0dHJpYnV0ZXMuZm9yRWFjaCgoYXR0cikgPT4ge1xuICAgICAgICBpZiAoIShhdHRyIGluIEljb25pZnlJY29uLnByb3RvdHlwZSkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShJY29uaWZ5SWNvbi5wcm90b3R5cGUsIGF0dHIsIHtcbiAgICAgICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QXR0cmlidXRlKGF0dHIpO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZShhdHRyLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUF0dHJpYnV0ZShhdHRyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIEFkZCBleHBvcnRlZCBmdW5jdGlvbnM6IGJvdGggYXMgc3RhdGljIGFuZCBpbnN0YW5jZSBtZXRob2RzXG4gICAgY29uc3QgZnVuY3Rpb25zID0gZXhwb3J0RnVuY3Rpb25zKCk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZnVuY3Rpb25zKSB7XG4gICAgICAgIEljb25pZnlJY29uW2tleV0gPSBJY29uaWZ5SWNvbi5wcm90b3R5cGVba2V5XSA9IGZ1bmN0aW9uc1trZXldO1xuICAgIH1cbiAgICAvLyBEZWZpbmUgbmV3IGNvbXBvbmVudFxuICAgIGN1c3RvbUVsZW1lbnRzLmRlZmluZShuYW1lLCBJY29uaWZ5SWNvbik7XG4gICAgcmV0dXJuIEljb25pZnlJY29uO1xufVxuXG4vKipcbiAqIENyZWF0ZSBleHBvcnRlZCBkYXRhOiBlaXRoZXIgY29tcG9uZW50IGluc3RhbmNlIG9yIGZ1bmN0aW9uc1xuICovXG5jb25zdCBJY29uaWZ5SWNvbkNvbXBvbmVudCA9IGRlZmluZUljb25pZnlJY29uKCkgfHwgZXhwb3J0RnVuY3Rpb25zKCk7XG4vKipcbiAqIEV4cG9ydCBmdW5jdGlvbnNcbiAqL1xuY29uc3QgeyBlbmFibGVDYWNoZSwgZGlzYWJsZUNhY2hlLCBpY29uRXhpc3RzLCBnZXRJY29uLCBsaXN0SWNvbnMsIGFkZEljb24sIGFkZENvbGxlY3Rpb24sIGNhbGN1bGF0ZVNpemUsIGJ1aWxkSWNvbiwgbG9hZEljb25zLCBsb2FkSWNvbiwgYWRkQVBJUHJvdmlkZXIsIF9hcGksIH0gPSBJY29uaWZ5SWNvbkNvbXBvbmVudDtcblxuZXhwb3J0IHsgSWNvbmlmeUljb25Db21wb25lbnQsIF9hcGksIGFkZEFQSVByb3ZpZGVyLCBhZGRDb2xsZWN0aW9uLCBhZGRJY29uLCBhcHBlbmRDdXN0b21TdHlsZSwgYnVpbGRJY29uLCBjYWxjdWxhdGVTaXplLCBkaXNhYmxlQ2FjaGUsIGVuYWJsZUNhY2hlLCBnZXRJY29uLCBpY29uRXhpc3RzLCBsaXN0SWNvbnMsIGxvYWRJY29uLCBsb2FkSWNvbnMgfTtcbiJdLCJuYW1lcyI6WyJkZWZhdWx0SWNvbkRpbWVuc2lvbnMiLCJPYmplY3QiLCJmcmVlemUiLCJsZWZ0IiwidG9wIiwid2lkdGgiLCJoZWlnaHQiLCJkZWZhdWx0SWNvblRyYW5zZm9ybWF0aW9ucyIsInJvdGF0ZSIsInZGbGlwIiwiaEZsaXAiLCJkZWZhdWx0SWNvblByb3BzIiwiZGVmYXVsdEV4dGVuZGVkSWNvblByb3BzIiwiYm9keSIsImhpZGRlbiIsImRlZmF1bHRJY29uU2l6ZUN1c3RvbWlzYXRpb25zIiwiZGVmYXVsdEljb25DdXN0b21pc2F0aW9ucyIsInJvdGF0ZUZyb21TdHJpbmciLCJ2YWx1ZSIsImRlZmF1bHRWYWx1ZSIsInVuaXRzIiwicmVwbGFjZSIsImNsZWFudXAiLCJ2YWx1ZTIiLCJudW0iLCJwYXJzZUludCIsImlzTmFOIiwic3BsaXQiLCJwYXJzZUZsb2F0Iiwic2xpY2UiLCJsZW5ndGgiLCJzZXBhcmF0b3IiLCJmbGlwRnJvbVN0cmluZyIsImN1c3RvbSIsImZsaXAiLCJmb3JFYWNoIiwic3RyIiwidHJpbSIsImRlZmF1bHRDdXN0b21pc2F0aW9ucyIsInByZXNlcnZlQXNwZWN0UmF0aW8iLCJnZXRDdXN0b21pc2F0aW9ucyIsIm5vZGUiLCJjdXN0b21pc2F0aW9ucyIsImF0dHIiLCJrZXkiLCJkZWYiLCJnZXRBdHRyaWJ1dGUiLCJoYXZlQ3VzdG9taXNhdGlvbnNDaGFuZ2VkIiwidmFsdWUxIiwibWF0Y2hJY29uTmFtZSIsInN0cmluZ1RvSWNvbiIsInZhbGlkYXRlIiwiYWxsb3dTaW1wbGVOYW1lIiwicHJvdmlkZXIiLCJjb2xvblNlcGFyYXRlZCIsInNoaWZ0IiwibmFtZTIiLCJwb3AiLCJwcmVmaXgiLCJyZXN1bHQiLCJuYW1lIiwidmFsaWRhdGVJY29uTmFtZSIsImRhc2hTZXBhcmF0ZWQiLCJqb2luIiwiaWNvbiIsIm1hdGNoIiwibWVyZ2VJY29uVHJhbnNmb3JtYXRpb25zIiwib2JqMSIsIm9iajIiLCJtZXJnZUljb25EYXRhIiwicGFyZW50IiwiY2hpbGQiLCJnZXRJY29uc1RyZWUiLCJkYXRhIiwibmFtZXMiLCJpY29ucyIsImFsaWFzZXMiLCJjcmVhdGUiLCJyZXNvbHZlZCIsInJlc29sdmUiLCJjb25jYXQiLCJrZXlzIiwiaW50ZXJuYWxHZXRJY29uRGF0YSIsInRyZWUiLCJjdXJyZW50UHJvcHMiLCJwYXJzZSIsInBhcnNlSWNvblNldCIsImNhbGxiYWNrIiwibm90X2ZvdW5kIiwiQXJyYXkiLCJwdXNoIiwiaXRlbSIsIm9wdGlvbmFsUHJvcGVydHlEZWZhdWx0cyIsImNoZWNrT3B0aW9uYWxQcm9wcyIsImRlZmF1bHRzIiwicHJvcCIsInF1aWNrbHlWYWxpZGF0ZUljb25TZXQiLCJvYmoiLCJkYXRhU3RvcmFnZSIsIm5ld1N0b3JhZ2UiLCJtaXNzaW5nIiwiU2V0IiwiZ2V0U3RvcmFnZSIsInByb3ZpZGVyU3RvcmFnZSIsImFkZEljb25TZXQiLCJzdG9yYWdlIiwiYWRkIiwiYWRkSWNvblRvU3RvcmFnZSIsImVyciIsImxpc3RJY29ucyQxIiwiYWxsSWNvbnMiLCJwcm92aWRlcnMiLCJwcm92aWRlcjIiLCJwcmVmaXhlcyIsInByZWZpeDIiLCJtYXAiLCJzaW1wbGVOYW1lcyIsImFsbG93U2ltcGxlTmFtZXMiLCJhbGxvdyIsImdldEljb25EYXRhIiwiaWNvbk5hbWUiLCJoYXMiLCJhZGRJY29uJDEiLCJhZGRDb2xsZWN0aW9uJDEiLCJhZGRlZCIsImljb25FeGlzdHMkMSIsImdldEljb24kMSIsInNvcnRJY29ucyIsImxvYWRlZCIsInBlbmRpbmciLCJzb3J0IiwiYSIsImIiLCJsb2NhbGVDb21wYXJlIiwibGFzdEljb24iLCJsb2NhbFN0b3JhZ2UiLCJsaXN0IiwicmVtb3ZlQ2FsbGJhY2siLCJzdG9yYWdlcyIsImlkIiwiaXRlbXMiLCJsb2FkZXJDYWxsYmFja3MiLCJmaWx0ZXIiLCJyb3ciLCJ1cGRhdGVDYWxsYmFja3MiLCJwZW5kaW5nQ2FsbGJhY2tzRmxhZyIsInNldFRpbWVvdXQiLCJoYXNQZW5kaW5nIiwib2xkTGVuZ3RoIiwiYWJvcnQiLCJpZENvdW50ZXIiLCJzdG9yZUNhbGxiYWNrIiwicGVuZGluZ1NvdXJjZXMiLCJiaW5kIiwic2V0QVBJTW9kdWxlIiwiZ2V0QVBJTW9kdWxlIiwibGlzdFRvSWNvbnMiLCJkZWZhdWx0Q29uZmlnIiwicmVzb3VyY2VzIiwiaW5kZXgiLCJ0aW1lb3V0IiwicmFuZG9tIiwiZGF0YUFmdGVyVGltZW91dCIsInNlbmRRdWVyeSIsImNvbmZpZyIsInBheWxvYWQiLCJxdWVyeSIsImRvbmUiLCJyZXNvdXJjZXNDb3VudCIsInN0YXJ0SW5kZXgiLCJNYXRoIiwiZmxvb3IiLCJuZXh0SW5kZXgiLCJzdGFydFRpbWUiLCJEYXRlIiwibm93Iiwic3RhdHVzIiwicXVlcmllc1NlbnQiLCJsYXN0RXJyb3IiLCJ0aW1lciIsInF1ZXVlIiwiZG9uZUNhbGxiYWNrcyIsInJlc2V0VGltZXIiLCJjbGVhclRpbWVvdXQiLCJzdWJzY3JpYmUiLCJvdmVyd3JpdGUiLCJnZXRRdWVyeVN0YXR1cyIsInF1ZXJpZXNQZW5kaW5nIiwiZmFpbFF1ZXJ5IiwiY2xlYXJRdWV1ZSIsIm1vZHVsZVJlc3BvbnNlIiwicmVzcG9uc2UiLCJpc0Vycm9yIiwicXVldWVkIiwiZXhlY05leHQiLCJpbmRleE9mIiwicmVzb3VyY2UiLCJzdGF0dXMyIiwiaW5pdFJlZHVuZGFuY3kiLCJjZmciLCJxdWVyaWVzIiwicXVlcnlDYWxsYmFjayIsImRvbmVDYWxsYmFjayIsInF1ZXJ5MiIsImVycm9yIiwiZmluZCIsImluc3RhbmNlIiwic2V0SW5kZXgiLCJnZXRJbmRleCIsImNyZWF0ZUFQSUNvbmZpZyIsInNvdXJjZSIsInBhdGgiLCJtYXhVUkwiLCJjb25maWdTdG9yYWdlIiwiZmFsbEJhY2tBUElTb3VyY2VzIiwiZmFsbEJhY2tBUEkiLCJhZGRBUElQcm92aWRlciQxIiwiY3VzdG9tQ29uZmlnIiwiZ2V0QVBJQ29uZmlnIiwibGlzdEFQSVByb3ZpZGVycyIsImVtcHR5Q2FsbGJhY2skMSIsInJlZHVuZGFuY3lDYWNoZSIsImdldFJlZHVuZGFuY3lDYWNoZSIsInJlZHVuZGFuY3kiLCJjYWNoZWRSZXVuZGFuY3kiLCJzZW5kQVBJUXVlcnkiLCJ0YXJnZXQiLCJzZW5kIiwiYXBpIiwiY2FjaGVkIiwibW9kdWxlS2V5IiwiYnJvd3NlckNhY2hlVmVyc2lvbiIsImJyb3dzZXJDYWNoZVByZWZpeCIsImJyb3dzZXJDYWNoZUNvdW50S2V5IiwiYnJvd3NlckNhY2hlVmVyc2lvbktleSIsImJyb3dzZXJTdG9yYWdlSG91ciIsImJyb3dzZXJTdG9yYWdlQ2FjaGVFeHBpcmF0aW9uIiwiZ2V0U3RvcmVkSXRlbSIsImZ1bmMiLCJnZXRJdGVtIiwic2V0U3RvcmVkSXRlbSIsInNldEl0ZW0iLCJyZW1vdmVTdG9yZWRJdGVtIiwicmVtb3ZlSXRlbSIsInNldEJyb3dzZXJTdG9yYWdlSXRlbXNDb3VudCIsInRvU3RyaW5nIiwiZ2V0QnJvd3NlclN0b3JhZ2VJdGVtc0NvdW50IiwiYnJvd3NlclN0b3JhZ2VDb25maWciLCJsb2NhbCIsInNlc3Npb24iLCJicm93c2VyU3RvcmFnZUVtcHR5SXRlbXMiLCJicm93c2VyU3RvcmFnZVN0YXR1cyIsInNldEJyb3dzZXJTdG9yYWdlU3RhdHVzIiwiX3dpbmRvdyIsIndpbmRvdyIsImdldEJyb3dzZXJTdG9yYWdlIiwiaXRlcmF0ZUJyb3dzZXJTdG9yYWdlIiwidmVyc2lvbiIsInRvdGFsMiIsImkiLCJtaW5UaW1lIiwicGFyc2VJdGVtIiwiSlNPTiIsInRvdGFsIiwiaW5pdEJyb3dzZXJTdG9yYWdlIiwiaWNvblNldCIsImxhc3RNb2RpZmllZCIsImxhc3RNb2RpZmllZENhY2hlZCIsIm1pbiIsInVwZGF0ZUxhc3RNb2RpZmllZCIsImxhc3RWYWx1ZSIsInN0b3JlSW5Ccm93c2VyU3RvcmFnZSIsInN0b3JlIiwic2V0Iiwic2l6ZSIsImRlbGV0ZSIsImZyb20iLCJzdHJpbmdpZnkiLCJhc3NpZ24iLCJlbXB0eUNhbGxiYWNrIiwibG9hZGVkTmV3SWNvbnMiLCJpY29uc0xvYWRlckZsYWciLCJsb2FkTmV3SWNvbnMiLCJpY29uc1RvTG9hZCIsImljb25zUXVldWVGbGFnIiwiaWNvbnMyIiwicGFyYW1zIiwicHJlcGFyZSIsInBhcnNlZCIsInBlbmRpbmdJY29ucyIsImNvbnNvbGUiLCJsb2FkSWNvbnMkMSIsImNsZWFuZWRJY29ucyIsInNvcnRlZEljb25zIiwiY2FsbENhbGxiYWNrIiwibmV3SWNvbnMiLCJzb3VyY2VzIiwibGFzdFByb3ZpZGVyIiwibGFzdFByZWZpeCIsInByb3ZpZGVyTmV3SWNvbnMiLCJwZW5kaW5nUXVldWUiLCJsb2FkSWNvbiQxIiwiUHJvbWlzZSIsImZ1bGZpbGwiLCJyZWplY3QiLCJpY29uT2JqIiwidGVzdEljb25PYmplY3QiLCJwYXJzZUljb25WYWx1ZSIsIm9ubG9hZCIsImxvYWRpbmciLCJnZXRJbmxpbmUiLCJoYXNBdHRyaWJ1dGUiLCJpc0J1Z2dlZFNhZmFyaSIsIm5hdmlnYXRvciIsInZlbmRvciIsImdldFJlbmRlck1vZGUiLCJtb2RlIiwidW5pdHNTcGxpdCIsInVuaXRzVGVzdCIsImNhbGN1bGF0ZVNpemUkMSIsInJhdGlvIiwicHJlY2lzaW9uIiwiY2VpbCIsIm9sZFBhcnRzIiwibmV3UGFydHMiLCJjb2RlIiwiaXNOdW1iZXIiLCJ0ZXN0IiwiaXNVbnNldEtleXdvcmQiLCJpY29uVG9TVkciLCJmdWxsSWNvbiIsImZ1bGxDdXN0b21pc2F0aW9ucyIsImJveCIsInByb3BzIiwidHJhbnNmb3JtYXRpb25zIiwicm90YXRpb24iLCJ0ZW1wVmFsdWUiLCJ1bnNoaWZ0IiwiY3VzdG9taXNhdGlvbnNXaWR0aCIsImN1c3RvbWlzYXRpb25zSGVpZ2h0IiwiYm94V2lkdGgiLCJib3hIZWlnaHQiLCJhdHRyaWJ1dGVzIiwic2V0QXR0ciIsInZpZXdCb3giLCJkZXRlY3RGZXRjaCIsImZldGNoIiwiZmV0Y2hNb2R1bGUiLCJzZXRGZXRjaCIsImZldGNoMiIsImdldEZldGNoIiwiY2FsY3VsYXRlTWF4TGVuZ3RoIiwibWF4SG9zdExlbmd0aCIsImhvc3QiLCJtYXgiLCJ1cmwiLCJzaG91bGRBYm9ydCIsInJlc3VsdHMiLCJtYXhMZW5ndGgiLCJ0eXBlIiwiZ2V0UGF0aCIsImljb25zTGlzdCIsInVybFBhcmFtcyIsIlVSTFNlYXJjaFBhcmFtcyIsInVyaSIsImRlZmF1bHRFcnJvciIsInRoZW4iLCJqc29uIiwiY2F0Y2giLCJmZXRjaEFQSU1vZHVsZSIsInRvZ2dsZUJyb3dzZXJDYWNoZSIsIm5vZGVBdHRyIiwiY3VzdG9tU3R5bGUiLCJhcHBlbmRDdXN0b21TdHlsZSIsInN0eWxlIiwidXBkYXRlU3R5bGUiLCJpbmxpbmUiLCJzdHlsZU5vZGUiLCJjaGlsZE5vZGVzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50Iiwic2V0QXR0cmlidXRlIiwiYXBwZW5kQ2hpbGQiLCJ0ZXh0Q29udGVudCIsImV4cG9ydEZ1bmN0aW9ucyIsIkljb25pZnlQcmVsb2FkIiwicHJlbG9hZCIsImUiLCJJY29uaWZ5UHJvdmlkZXJzIiwiX2FwaSIsImVuYWJsZUNhY2hlIiwiZGlzYWJsZUNhY2hlIiwiaWNvbkV4aXN0cyIsImdldEljb24iLCJsaXN0SWNvbnMiLCJhZGRJY29uIiwiYWRkQ29sbGVjdGlvbiIsImNhbGN1bGF0ZVNpemUiLCJidWlsZEljb24iLCJsb2FkSWNvbnMiLCJsb2FkSWNvbiIsImFkZEFQSVByb3ZpZGVyIiwiaWNvblRvSFRNTCIsInJlbmRlckF0dHJpYnNIVE1MIiwiZW5jb2RlU1ZHZm9yVVJMIiwic3ZnIiwic3ZnVG9EYXRhIiwic3ZnVG9VUkwiLCJtb25vdG9uZVByb3BzIiwiY29sb3JlZFByb3BzIiwicHJvcHNUb0FkZCIsImltYWdlIiwicmVwZWF0IiwicHJvcHNUb0FkZFRvIiwiZml4U2l6ZSIsInJlbmRlclNQQU4iLCJ1c2VNYXNrIiwicmVuZGVyQXR0cmlicyIsImh0bWwiLCJzdmdTdHlsZSIsInN0eWxlcyIsInNldFByb3BlcnR5IiwicG9saWN5IiwiY3JlYXRlUG9saWN5IiwidHJ1c3RlZFR5cGVzIiwiY3JlYXRlSFRNTCIsInMiLCJjbGVhblVwSW5uZXJIVE1MIiwicmVuZGVyU1ZHIiwiaW5uZXJIVE1MIiwiZmlyc3RDaGlsZCIsInJlbmRlckljb24iLCJzdGF0ZSIsImljb25EYXRhIiwicmVuZGVyRGF0YSIsInJlbmRlcmVkTW9kZSIsIm9sZE5vZGUiLCJ0YWciLCJ0YWdOYW1lIiwidG9VcHBlckNhc2UiLCJyZXBsYWNlQ2hpbGQiLCJzZXRQZW5kaW5nU3RhdGUiLCJsYXN0U3RhdGUiLCJsYXN0UmVuZGVyIiwicmVuZGVyZWQiLCJkZWZpbmVJY29uaWZ5SWNvbiIsImN1c3RvbUVsZW1lbnRzIiwiUGFyZW50Q2xhc3MiLCJIVE1MRWxlbWVudCIsIkNvbmZsaWN0aW5nQ2xhc3MiLCJnZXQiLCJJY29uaWZ5SWNvbiIsImNvbnN0cnVjdG9yIiwiX2NoZWNrUXVldWVkIiwicm9vdCIsIl9zaGFkb3dSb290IiwiYXR0YWNoU2hhZG93IiwiX3N0YXRlIiwiX3F1ZXVlQ2hlY2siLCJvYnNlcnZlZEF0dHJpYnV0ZXMiLCJhdHRyaWJ1dGVDaGFuZ2VkQ2FsbGJhY2siLCJuZXdJbmxpbmUiLCJyZW1vdmVBdHRyaWJ1dGUiLCJyZXN0YXJ0QW5pbWF0aW9uIiwibGFzdENoaWxkIiwic2V0Q3VycmVudFRpbWUiLCJfY2hlY2siLCJuZXdJY29uIiwiX2ljb25DaGFuZ2VkIiwiYXR0ck1vZGUiLCJfcmVuZGVySWNvbiIsIm5ld1ZhbHVlIiwiX2dvdEljb25EYXRhIiwicHJvdG90eXBlIiwiZGVmaW5lUHJvcGVydHkiLCJmdW5jdGlvbnMiLCJkZWZpbmUiLCJJY29uaWZ5SWNvbkNvbXBvbmVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/iconify-icon@1.0.8/node_modules/iconify-icon/dist/iconify-icon.mjs\n");

/***/ })

};
;